diff --git a/src/runtime/cgo/gcc_linux_386.c b/src/runtime/cgo/gcc_linux_386.c
index 30fe92b..7a6b846 100644
--- a/src/runtime/cgo/gcc_linux_386.c
+++ b/src/runtime/cgo/gcc_linux_386.c
@@ -14,6 +14,8 @@ static void (*setg_gcc)(void*);
 void (*x_cgo_inittls)(void);
 void* (*x_cgo_threadentry)(void*);
 
+#define MIN_STACKSIZE (256 * 1024)
+
 void
 x_cgo_init(G *g, void (*setg)(void*))
 {
@@ -51,6 +53,10 @@ _cgo_sys_thread_start(ThreadStart *ts)
 	pthread_attr_init(&attr);
 	size = 0;
 	pthread_attr_getstacksize(&attr, &size);
+	// musl libc set default stack size to 80k which is a bit small
+	if (size < MIN_STACKSIZE)
+		if (pthread_attr_setstacksize(&attr, MIN_STACKSIZE) == 0)
+			size = MIN_STACKSIZE;
 	// Leave stacklo=0 and set stackhi=size; mstack will do the rest.
 	ts->g->stackhi = size;
 	err = pthread_create(&p, &attr, threadentry, ts);
diff --git a/src/runtime/cgo/gcc_linux_amd64.c b/src/runtime/cgo/gcc_linux_amd64.c
index 0c34c66..6c090b7 100644
--- a/src/runtime/cgo/gcc_linux_amd64.c
+++ b/src/runtime/cgo/gcc_linux_amd64.c
@@ -16,6 +16,8 @@ static void (*setg_gcc)(void*);
 void (*x_cgo_inittls)(void);
 void* (*x_cgo_threadentry)(void*);
 
+#define MIN_STACKSIZE (512 * 1024)
+
 void
 x_cgo_init(G* g, void (*setg)(void*))
 {
@@ -68,6 +70,10 @@ _cgo_sys_thread_start(ThreadStart *ts)
 
 	pthread_attr_init(&attr);
 	pthread_attr_getstacksize(&attr, &size);
+	// musl libc set default stack size to 80k which is a bit small
+	if (size < MIN_STACKSIZE)
+		if (pthread_attr_setstacksize(&attr, MIN_STACKSIZE) == 0)
+			size = MIN_STACKSIZE;
 	// Leave stacklo=0 and set stackhi=size; mstack will do the rest.
 	ts->g->stackhi = size;
 	err = pthread_create(&p, &attr, threadentry, ts);
diff --git a/src/runtime/cgo/gcc_linux_arm.c b/src/runtime/cgo/gcc_linux_arm.c
index 945c3f1..7abe781 100644
--- a/src/runtime/cgo/gcc_linux_arm.c
+++ b/src/runtime/cgo/gcc_linux_arm.c
@@ -12,6 +12,8 @@ static void *threadentry(void*);
 void (*x_cgo_inittls)(void **tlsg, void **tlsbase);
 void (*setg_gcc)(void*);
 
+#define MIN_STACKSIZE (256*1024)
+
 void
 _cgo_sys_thread_start(ThreadStart *ts)
 {
@@ -31,6 +33,10 @@ _cgo_sys_thread_start(ThreadStart *ts)
 	pthread_attr_init(&attr);
 	size = 0;
 	pthread_attr_getstacksize(&attr, &size);
+	// musl libc set default stack size to 80k which is a bit small
+	if (size < MIN_STACKSIZE)
+		if (pthread_attr_setstacksize(&attr, MIN_STACKSIZE) == 0)
+			size = MIN_STACKSIZE;
 	// Leave stacklo=0 and set stackhi=size; mstack will do the rest.
 	ts->g->stackhi = size;
 	err = pthread_create(&p, &attr, threadentry, ts);
diff --git a/src/runtime/cgo/gcc_linux_arm64.c b/src/runtime/cgo/gcc_linux_arm64.c
index ca9ba0b..8e0ff14 100644
--- a/src/runtime/cgo/gcc_linux_arm64.c
+++ b/src/runtime/cgo/gcc_linux_arm64.c
@@ -12,6 +12,8 @@ static void *threadentry(void*);
 void (*x_cgo_inittls)(void **tlsg, void **tlsbase);
 void (*setg_gcc)(void*);
 
+#define MIN_STACKSIZE (512*1024)
+
 void
 _cgo_sys_thread_start(ThreadStart *ts)
 {
@@ -31,6 +33,10 @@ _cgo_sys_thread_start(ThreadStart *ts)
 	pthread_attr_init(&attr);
 	size = 0;
 	pthread_attr_getstacksize(&attr, &size);
+	// musl libc set default stack size to 80k which is a bit small
+	if (size < MIN_STACKSIZE)
+		if (pthread_attr_setstacksize(&attr, MIN_STACKSIZE) == 0)
+			size = MIN_STACKSIZE;
 	// Leave stacklo=0 and set stackhi=size; mstack will do the rest.
 	ts->g->stackhi = size;
 	err = pthread_create(&p, &attr, threadentry, ts);
diff --git a/src/runtime/cgo/gcc_linux_ppc64x.c b/src/runtime/cgo/gcc_linux_ppc64x.c
index fb19805..88911c6 100644
--- a/src/runtime/cgo/gcc_linux_ppc64x.c
+++ b/src/runtime/cgo/gcc_linux_ppc64x.c
@@ -14,6 +14,8 @@ static void *threadentry(void*);
 void (*x_cgo_inittls)(void **tlsg, void **tlsbase);
 static void (*setg_gcc)(void*);
 
+#define MIN_STACKSIZE (512*1024)
+
 void
 x_cgo_init(G *g, void (*setg)(void*), void **tlsbase)
 {
@@ -41,6 +43,10 @@ _cgo_sys_thread_start(ThreadStart *ts)
 
 	pthread_attr_init(&attr);
 	pthread_attr_getstacksize(&attr, &size);
+	// musl libc set default stack size to 80k which is a bit small
+	if (size < MIN_STACKSIZE)
+		if (pthread_attr_setstacksize(&attr, MIN_STACKSIZE) == 0)
+			size = MIN_STACKSIZE;
 	// Leave stacklo=0 and set stackhi=size; mstack will do the rest.
 	ts->g->stackhi = size;
 	err = pthread_create(&p, &attr, threadentry, ts);
