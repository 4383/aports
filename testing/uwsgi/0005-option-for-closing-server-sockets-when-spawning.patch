From de160406dbe358fb599eb8343e82f18252247a19 Mon Sep 17 00:00:00 2001
From: Kaarle Ritvanen <kaarle.ritvanen@datakunkku.fi>
Date: Wed, 1 Jan 2014 03:51:56 +0200
Subject: [PATCH 5/5] option for closing server sockets when spawning

If server fd is not closed, it is not possible to restart uwsgi if the
spawned process is still running as it keeps the address/port bound.
---
 core/master_utils.c | 1 +
 core/socket.c       | 3 +++
 core/uwsgi.c        | 3 ++-
 uwsgi.h             | 2 ++
 4 files changed, 8 insertions(+), 1 deletion(-)

diff --git a/core/master_utils.c b/core/master_utils.c
index 89151a0..6316209 100644
--- a/core/master_utils.c
+++ b/core/master_utils.c
@@ -407,6 +407,7 @@ void uwsgi_reload(char **argv) {
 	/* check fd table (a module can obviosly open some fd on initialization...) */
 	uwsgi_log("closing all non-uwsgi socket fds > 2 (max_fd = %d)...\n", (int) uwsgi.max_fd);
 	for (i = 3; i < (int) uwsgi.max_fd; i++) {
+		fcntl(i, F_SETFD, 0);
 
 		if (uwsgi_fd_is_safe(i)) continue;
 
diff --git a/core/socket.c b/core/socket.c
index 6d5d7d7..8b66a47 100644
--- a/core/socket.c
+++ b/core/socket.c
@@ -84,6 +84,9 @@ static int create_server_socket(int domain, int type) {
 		return -1;
 	}
 
+	if (uwsgi.close_on_exec2 && fcntl(serverfd, F_SETFD, FD_CLOEXEC) < 0)
+		uwsgi_error("fcntl()");
+
 	if (domain != AF_UNIX) {
 		int reuse = 1;
 		if (setsockopt(serverfd, SOL_SOCKET, SO_REUSEADDR, (const void *) &reuse, sizeof(int)) < 0) {
diff --git a/core/uwsgi.c b/core/uwsgi.c
index 51821bc..d3d6538 100644
--- a/core/uwsgi.c
+++ b/core/uwsgi.c
@@ -871,7 +871,8 @@ static struct uwsgi_option uwsgi_base_options[] = {
 	{"disable-sendfile", no_argument, 0, "disable sendfile() and rely on boring read()/write()", uwsgi_opt_true, &uwsgi.disable_sendfile, 0},
 
 	{"check-cache", optional_argument, 0, "check for response data in the specified cache (empty for default cache)", uwsgi_opt_set_str, &uwsgi.use_check_cache, 0},
-	{"close-on-exec", no_argument, 0, "set close-on-exec on sockets (could be required for spawning processes in requests)", uwsgi_opt_true, &uwsgi.close_on_exec, 0},
+	{"close-on-exec", no_argument, 0, "set close-on-exec on connection sockets (could be required for spawning processes in requests)", uwsgi_opt_true, &uwsgi.close_on_exec, 0},
+	{"close-on-exec2", no_argument, 0, "set close-on-exec on server sockets (could be required for spawning processes in requests)", uwsgi_opt_true, &uwsgi.close_on_exec2, 0},
 	{"mode", required_argument, 0, "set uWSGI custom mode", uwsgi_opt_set_str, &uwsgi.mode, 0},
 	{"env", required_argument, 0, "set environment variable", uwsgi_opt_set_env, NULL, 0},
 	{"envdir", required_argument, 0, "load a daemontools compatible envdir", uwsgi_opt_add_string_list, &uwsgi.envdirs, 0},
diff --git a/uwsgi.h b/uwsgi.h
index 29dfc2d..ccb41d4 100644
--- a/uwsgi.h
+++ b/uwsgi.h
@@ -2516,6 +2516,8 @@ struct uwsgi_server {
 	void (*gbcw_hook) (void);
 
 	int close_on_exec;
+	int close_on_exec2;
+
 	int tcp_nodelay;
 
 	char *loop;
-- 
1.8.4.2

