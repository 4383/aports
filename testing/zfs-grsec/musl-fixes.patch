diff --git a/cmd/mount_zfs/mount_zfs.c b/cmd/mount_zfs/mount_zfs.c
index 6cb23d1..cf92b86 100644
--- a/cmd/mount_zfs/mount_zfs.c
+++ b/cmd/mount_zfs/mount_zfs.c
@@ -31,6 +31,7 @@
 #include <sys/stat.h>
 #include <libzfs.h>
 #include <locale.h>
+#include <fcntl.h>
 
 libzfs_handle_t *g_zfs;
 
diff --git a/include/sys/zfs_context.h b/include/sys/zfs_context.h
index ec2a7de..6424ae5 100644
--- a/include/sys/zfs_context.h
+++ b/include/sys/zfs_context.h
@@ -1,31 +1,30 @@
 /*
  * CDDL HEADER START
  *
- * The contents of this file are subject to the terms of the
- * Common Development and Distribution License (the "License").
- * You may not use this file except in compliance with the License.
+ * The contents of this file are subject to the terms of the Common Development
+ * and Distribution License (the "License").  You may not use this file except
+ * in compliance with the License.
  *
- * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
- * or http://www.opensolaris.org/os/licensing.
- * See the License for the specific language governing permissions
- * and limitations under the License.
+ * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE or
+ * http://www.opensolaris.org/os/licensing.  See the License for the specific
+ * language governing permissions and limitations under the License.
  *
- * When distributing Covered Code, include this CDDL HEADER in each
- * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
- * If applicable, add the following below this CDDL HEADER, with the
- * fields enclosed by brackets "[]" replaced with your own identifying
- * information: Portions Copyright [yyyy] [name of copyright owner]
+ * When distributing Covered Code, include this CDDL HEADER in each file and
+ * include the License file at usr/src/OPENSOLARIS.LICENSE.  If applicable, add
+ * the following below this CDDL HEADER, with the fields enclosed by brackets
+ * "[]" replaced with your own identifying information: Portions Copyright
+ * [yyyy] [name of copyright owner]
  *
  * CDDL HEADER END
  */
 /*
- * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
- * Use is subject to license terms.
+ * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.  Use is subject
+ * to license terms.
  */
 /*
- * Copyright 2011 Nexenta Systems, Inc. All rights reserved.
- * Copyright (c) 2012, Joyent, Inc. All rights reserved.
- * Copyright (c) 2013 by Delphix. All rights reserved.
+ * Copyright 2011 Nexenta Systems, Inc. All rights reserved.  Copyright (c)
+ * 2012, Joyent, Inc. All rights reserved.  Copyright (c) 2013 by Delphix. All
+ * rights reserved.
  */
 
 #ifndef _SYS_ZFS_CONTEXT_H
@@ -614,12 +613,12 @@ extern void delay(clock_t ticks);
 #define	minclsyspri	60
 #define	maxclsyspri	99
 
-#define	CPU_SEQID	(pthread_self() & (max_ncpus - 1))
+#define	CPU_SEQID	((long long)pthread_self() & (max_ncpus - 1))
 
 #define	kcred		NULL
 #define	CRED()		NULL
 
-#define	ptob(x)		((x) * PAGESIZE)
+#define	ptob(x)		((x) * SPL_PAGESIZE)
 
 extern uint64_t physmem;
 
diff --git a/lib/libspl/include/assert.h b/lib/libspl/include/assert.h
index d749d1e..4791dcf 100644
--- a/lib/libspl/include/assert.h
+++ b/lib/libspl/include/assert.h
@@ -42,6 +42,17 @@ __assert_c99(const char *expr, const char *file, int line, const char *func)
 }
 #endif  /* __assert_c99 */
 
+#ifndef __assert
+static inline void
+__assert(const char *expr, const char *file, int line)
+{
+	fprintf(stderr, "%s:%i: %s: Assertion failed.\n", file, line, expr);
+	abort();
+}
+#else
+extern void __assert(const char *, const char *, int);
+#endif
+
 #ifndef verify
 #if defined(__STDC__)
 #if __STDC_VERSION__ - 0 >= 199901L
@@ -61,8 +72,6 @@ __assert_c99(const char *expr, const char *file, int line, const char *func)
 #define	VERIFY	verify
 #define	ASSERT	assert
 
-extern void __assert(const char *, const char *, int);
-
 /* BEGIN CSTYLED */
 #define	VERIFY3_IMPL(LEFT, OP, RIGHT, TYPE) do { \
 	const TYPE __left = (TYPE)(LEFT); \
diff --git a/lib/libspl/include/devid.h b/lib/libspl/include/devid.h
index 5406c33..1675cfd 100644
--- a/lib/libspl/include/devid.h
+++ b/lib/libspl/include/devid.h
@@ -29,6 +29,11 @@
 
 #include <stdlib.h>
 
+#if !defined(__DEFINED_dev_t)
+#define __NEED_dev_t
+#include <bits/alltypes.h>
+#endif
+
 typedef int ddi_devid_t;
 
 typedef struct devid_nmlist {
diff --git a/lib/libspl/include/rpc/xdr.h b/lib/libspl/include/rpc/xdr.h
index 99500d6..27e7590 100644
--- a/lib/libspl/include/rpc/xdr.h
+++ b/lib/libspl/include/rpc/xdr.h
@@ -60,6 +60,8 @@ typedef struct xdr_bytesrec {
 #define	XDR_RDMAGET	4
 #define	XDR_RDMASET	5
 
+#ifndef HAVE_TIRPC
 extern bool_t xdr_control(XDR *xdrs, int request, void *info);
+#endif
 
 #endif
diff --git a/lib/libspl/include/sys/inttypes.h b/lib/libspl/include/sys/inttypes.h
index d7d0639..9707fa2 100644
--- a/lib/libspl/include/sys/inttypes.h
+++ b/lib/libspl/include/sys/inttypes.h
@@ -30,5 +30,9 @@
 #include <inttypes.h>
 
 #define	_INT64_TYPE
+#ifndef RLIM64_INFINITY
+#define RLIM64_INFINITY		(~0ULL)
+#endif
+
 
 #endif
diff --git a/lib/libspl/include/sys/param.h b/lib/libspl/include/sys/param.h
index 4090cef..de408e2 100644
--- a/lib/libspl/include/sys/param.h
+++ b/lib/libspl/include/sys/param.h
@@ -57,6 +57,6 @@
 #define	MAXUID		UINT32_MAX	/* max user id */
 #define	MAXPROJID	MAXUID		/* max project id */
 
-#define	PAGESIZE	(sysconf(_SC_PAGESIZE))
+#define	SPL_PAGESIZE	(sysconf(_SC_PAGESIZE))
 
 #endif
diff --git a/lib/libspl/include/sys/sysmacros.h b/lib/libspl/include/sys/sysmacros.h
index 698b0a7..1530177 100644
--- a/lib/libspl/include/sys/sysmacros.h
+++ b/lib/libspl/include/sys/sysmacros.h
@@ -66,11 +66,11 @@
  * that the result is correctly calculated based on the data type of (x),
  * which is passed in as the last argument, regardless of the data
  * type of the alignment.  For example, if (x) is of type uint64_t,
- * and we want to round it up to a page boundary using "PAGESIZE" as
+ * and we want to round it up to a page boundary using "SPL_PAGESIZE" as
  * the alignment, we can do either
- *      P2ROUNDUP(x, (uint64_t)PAGESIZE)
+ *      P2ROUNDUP(x, (uint64_t)SPL_PAGESIZE)
  * or
- *      P2ROUNDUP_TYPED(x, PAGESIZE, uint64_t)
+ *      P2ROUNDUP_TYPED(x, SPL_PAGESIZE, uint64_t)
  */
 #define	P2ALIGN_TYPED(x, align, type)		\
 	((type)(x) & -(type)(align))
diff --git a/lib/libspl/include/sys/time.h b/lib/libspl/include/sys/time.h
index f0da440..aa96c39 100644
--- a/lib/libspl/include/sys/time.h
+++ b/lib/libspl/include/sys/time.h
@@ -58,6 +58,11 @@
 #define	NSEC2MSEC(n)    ((n) / (NANOSEC / MILLISEC))
 #endif
 
+#ifndef HAVE_HR_TYPES
+typedef long long	longlong_t;
+typedef longlong_t	hrtime_t;
+typedef struct timespec	timestruc_t;
+#endif
 extern hrtime_t gethrtime(void);
 extern void gethrestime(timestruc_t *);
 
diff --git a/lib/libspl/include/sys/types.h b/lib/libspl/include/sys/types.h
index bd34dec..e7e1e13 100644
--- a/lib/libspl/include/sys/types.h
+++ b/lib/libspl/include/sys/types.h
@@ -60,6 +60,7 @@ typedef long		spgcnt_t;	/* signed number of pages */
 typedef longlong_t	hrtime_t;
 typedef struct timespec	timestruc_t;
 typedef struct timespec timespec_t;
+#define HAVE_HR_TYPES
 
 typedef short		pri_t;
 
diff --git a/lib/libspl/include/sys/va_list.h b/lib/libspl/include/sys/va_list.h
index 04ad148..bb011ba 100644
--- a/lib/libspl/include/sys/va_list.h
+++ b/lib/libspl/include/sys/va_list.h
@@ -29,7 +29,9 @@
 
 #include <stdarg.h>
 
-#ifndef __va_list
+#ifdef HAVE_MUSL
+typedef void* __va_list;
+#else
 typedef __gnuc_va_list __va_list;
 #endif
 
diff --git a/lib/libspl/timestamp.c b/lib/libspl/timestamp.c
index a4f4cf4..a177270 100644
--- a/lib/libspl/timestamp.c
+++ b/lib/libspl/timestamp.c
@@ -28,6 +28,10 @@
 #include <langinfo.h>
 #include "statcommon.h"
 
+#ifndef _DATE_FMT
+#define _DATE_FMT D_FMT
+#endif
+
 /*
  * Print timestamp as decimal reprentation of time_t value (-T u was specified)
  * or in date(1) format (-T d was specified).
diff --git a/lib/libspl/xdr.c b/lib/libspl/xdr.c
index 288a338..c8a6fe3 100644
--- a/lib/libspl/xdr.c
+++ b/lib/libspl/xdr.c
@@ -29,6 +29,7 @@
  * under license from the Regents of the University of California.
  */
 
+#ifndef HAVE_TIRPC
 #include <rpc/xdr.h>
 
 /*
@@ -76,3 +77,4 @@ xdr_control(XDR *xdrs, int request, void *info)
 	}
 	return (FALSE);
 }
+#endif
diff --git a/lib/libzpool/kernel.c b/lib/libzpool/kernel.c
index 05bbd06..32e9607 100644
--- a/lib/libzpool/kernel.c
+++ b/lib/libzpool/kernel.c
@@ -180,7 +180,7 @@ zk_thread_create(caddr_t stk, size_t stksize, thread_func_t func, void *arg,
 
 	VERIFY3S(pthread_attr_init(&attr), ==, 0);
 	VERIFY3S(pthread_attr_setstacksize(&attr, stack), ==, 0);
-	VERIFY3S(pthread_attr_setguardsize(&attr, PAGESIZE), ==, 0);
+	VERIFY3S(pthread_attr_setguardsize(&attr, SPL_PAGESIZE), ==, 0);
 	VERIFY3S(pthread_attr_setdetachstate(&attr, detachstate), ==, 0);
 
 	VERIFY3S(pthread_create(&kt->t_tid, &attr, &zk_thread_helper, kt),
@@ -901,7 +901,7 @@ static char ce_prefix[CE_IGNORE][10] = { "", "NOTICE: ", "WARNING: ", "" };
 static char ce_suffix[CE_IGNORE][2] = { "", "\n", "\n", "" };
 
 void
-vpanic(const char *fmt, va_list adx)
+vpanic(const char *fmt, __va_list adx)
 {
 	(void) fprintf(stderr, "error: ");
 	(void) vfprintf(stderr, fmt, adx);
@@ -921,7 +921,7 @@ panic(const char *fmt, ...)
 }
 
 void
-vcmn_err(int ce, const char *fmt, va_list adx)
+vcmn_err(int ce, const char *fmt, __va_list adx)
 {
 	if (ce == CE_PANIC)
 		vpanic(fmt, adx);
diff --git a/module/nvpair/nvpair.c b/module/nvpair/nvpair.c
index f5c3166..750556b 100644
--- a/module/nvpair/nvpair.c
+++ b/module/nvpair/nvpair.c
@@ -3251,8 +3251,12 @@ nvs_xdr_nvpair(nvstream_t *nvs, nvpair_t *nvp, size_t *size)
 			return (0);
 
 		/* sanity check the size parameter */
+#ifndef HAVE_TIRPC
 		if (!xdr_control(xdr, XDR_GET_BYTES_AVAIL, &bytesrec))
 			return (EFAULT);
+#else
+		xdr_control(xdr, XDR_GET_BYTES_AVAIL, &bytesrec);
+#endif
 
 		if (*size > NVS_XDR_MAX_LEN(bytesrec.xc_num_avail))
 			return (EFAULT);
diff --git a/module/zcommon/zfs_uio.c b/module/zcommon/zfs_uio.c
index 90376f2..6eabecf 100644
--- a/module/zcommon/zfs_uio.c
+++ b/module/zcommon/zfs_uio.c
@@ -44,6 +44,7 @@
  */
 #ifdef _KERNEL
 
+#include <sys/param.h>
 #include <sys/types.h>
 #include <sys/uio_impl.h>
 
@@ -144,7 +145,7 @@ uio_prefaultpages(ssize_t n, struct uio *uio)
 				bcopy(p, &tmp, 1);
 				break;
 			}
-			incr = MIN(cnt, PAGESIZE);
+			incr = MIN(cnt, SPL_PAGESIZE);
 			p += incr;
 			cnt -= incr;
 		}
diff --git a/module/zfs/arc.c b/module/zfs/arc.c
index 387faaf..e2aa10d 100644
--- a/module/zfs/arc.c
+++ b/module/zfs/arc.c
@@ -135,6 +135,7 @@
 #include <sys/vdev.h>
 #include <sys/vdev_impl.h>
 #include <sys/dsl_pool.h>
+#include <linux/param.h>
 #ifdef _KERNEL
 #include <sys/vmsystm.h>
 #include <vm/anon.h>
@@ -1002,7 +1003,7 @@ buf_init(void)
 	 * with an average 64K block size.  The table will take up
 	 * totalmem*sizeof(void*)/64K (eg. 128KB/GB with 8-byte pointers).
 	 */
-	while (hsize * 65536 < physmem * PAGESIZE)
+	while (hsize * 65536 < physmem * SPL_PAGESIZE)
 		hsize <<= 1;
 retry:
 	buf_hash_table.ht_mask = hsize - 1;
@@ -2500,7 +2501,7 @@ arc_adapt_thread(void)
 
 		/* Allow the module options to be changed */
 		if (zfs_arc_max > 64 << 20 &&
-		    zfs_arc_max < physmem * PAGESIZE &&
+		    zfs_arc_max < physmem * SPL_PAGESIZE &&
 		    zfs_arc_max != arc_c_max)
 			arc_c_max = zfs_arc_max;
 
@@ -4087,7 +4088,7 @@ arc_init(void)
 	zfs_arc_min_prefetch_lifespan = 1 * hz;
 
 	/* Start out with 1/8 of all memory */
-	arc_c = physmem * PAGESIZE / 8;
+	arc_c = physmem * SPL_PAGESIZE / 8;
 
 #ifdef _KERNEL
 	/*
@@ -4113,7 +4114,7 @@ arc_init(void)
 	 * Allow the tunables to override our calculations if they are
 	 * reasonable (ie. over 64MB)
 	 */
-	if (zfs_arc_max > 64<<20 && zfs_arc_max < physmem * PAGESIZE)
+	if (zfs_arc_max > 64<<20 && zfs_arc_max < physmem * SPL_PAGESIZE)
 		arc_c_max = zfs_arc_max;
 	if (zfs_arc_min > 0 && zfs_arc_min <= arc_c_max)
 		arc_c_min = zfs_arc_min;
@@ -4212,11 +4213,11 @@ arc_init(void)
 	 * zfs_dirty_data_max_max (default 25% of physical memory).
 	 */
 	if (zfs_dirty_data_max_max == 0)
-		zfs_dirty_data_max_max = physmem * PAGESIZE *
+		zfs_dirty_data_max_max = physmem * SPL_PAGESIZE *
 		    zfs_dirty_data_max_max_percent / 100;
 
 	if (zfs_dirty_data_max == 0) {
-		zfs_dirty_data_max = physmem * PAGESIZE *
+		zfs_dirty_data_max = physmem * SPL_PAGESIZE *
 		    zfs_dirty_data_max_percent / 100;
 		zfs_dirty_data_max = MIN(zfs_dirty_data_max,
 		    zfs_dirty_data_max_max);
diff --git a/module/zfs/dbuf.c b/module/zfs/dbuf.c
index 4f17506..ef5fac6 100644
--- a/module/zfs/dbuf.c
+++ b/module/zfs/dbuf.c
@@ -302,7 +302,7 @@ dbuf_init(void)
 	 * with an average 4K block size.  The table will take up
 	 * totalmem*sizeof(void*)/4K (i.e. 2MB/GB with 8-byte pointers).
 	 */
-	while (hsize * 4096 < physmem * PAGESIZE)
+	while (hsize * 4096 < physmem * SPL_PAGESIZE)
 		hsize <<= 1;
 
 retry:
diff --git a/module/zfs/zfs_vnops.c b/module/zfs/zfs_vnops.c
index 91f743a..d45aeda 100644
--- a/module/zfs/zfs_vnops.c
+++ b/module/zfs/zfs_vnops.c
@@ -364,7 +364,7 @@ update_pages(struct inode *ip, int64_t start, int len,
  * On Read:	We "read" preferentially from memory mapped pages,
  *		else we default from the dmu buffer.
  *
- * NOTE: We will always "break up" the IO into PAGESIZE uiomoves when
+ * NOTE: We will always "break up" the IO into SPL_PAGESIZE uiomoves when
  *	 the file is memory mapped.
  */
 static int
@@ -4118,11 +4118,11 @@ zfs_fillpage(struct inode *ip, struct page *pl[], int nr_pages)
 	 */
 	page_idx = 0;
 	cur_pp   = pl[0];
-	for (total = io_off + io_len; io_off < total; io_off += PAGESIZE) {
+	for (total = io_off + io_len; io_off < total; io_off += SPL_PAGESIZE) {
 		caddr_t va;
 
 		va = kmap(cur_pp);
-		err = dmu_read(os, zp->z_id, io_off, PAGESIZE, va,
+		err = dmu_read(os, zp->z_id, io_off, SPL_PAGESIZE, va,
 		    DMU_READ_PREFETCH);
 		kunmap(cur_pp);
 		if (err) {
diff --git a/module/zfs/zio.c b/module/zfs/zio.c
index 332d50c..8f9b0e7 100644
--- a/module/zfs/zio.c
+++ b/module/zfs/zio.c
@@ -133,13 +133,13 @@ zio_init(void)
 	zio_link_cache = kmem_cache_create("zio_link_cache",
 	    sizeof (zio_link_t), 0, NULL, NULL, NULL, NULL, NULL, 0);
 	zio_vdev_cache = kmem_cache_create("zio_vdev_cache", sizeof (vdev_io_t),
-	    PAGESIZE, NULL, NULL, NULL, NULL, NULL, 0);
+	    SPL_PAGESIZE, NULL, NULL, NULL, NULL, NULL, 0);
 
 	/*
 	 * For small buffers, we want a cache for each multiple of
 	 * SPA_MINBLOCKSIZE.  For medium-size buffers, we want a cache
 	 * for each quarter-power of 2.  For large buffers, we want
-	 * a cache for each multiple of PAGESIZE.
+	 * a cache for each multiple of SPL_PAGESIZE.
 	 */
 	for (c = 0; c < SPA_MAXBLOCKSIZE >> SPA_MINBLOCKSHIFT; c++) {
 		size_t size = (c + 1) << SPA_MINBLOCKSHIFT;
@@ -156,13 +156,13 @@ zio_init(void)
 		 * kernel when modifying a non-watched buffer that shares the
 		 * page with a watched buffer.
 		 */
-		if (arc_watch && !IS_P2ALIGNED(size, PAGESIZE))
+		if (arc_watch && !IS_P2ALIGNED(size, SPL_PAGESIZE))
 			continue;
 #endif
 		if (size <= 4 * SPA_MINBLOCKSIZE) {
 			align = SPA_MINBLOCKSIZE;
-		} else if (IS_P2ALIGNED(size, PAGESIZE)) {
-			align = PAGESIZE;
+		} else if (IS_P2ALIGNED(size, SPL_PAGESIZE)) {
+			align = SPL_PAGESIZE;
 		} else if (IS_P2ALIGNED(size, p2 >> 2)) {
 			align = p2 >> 2;
 		}
