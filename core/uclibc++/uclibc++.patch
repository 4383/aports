--- a/include/associative_base	Sun Jun  3 22:51:12 2007
+++ b/include/associative_base	Sun Jan 11 21:50:05 2009
@@ -74,7 +74,7 @@
 	typedef typename std::reverse_iterator<const_iterator>		const_reverse_iterator;
 
 
-	explicit __base_associative(const Compare& comp, const Allocator& A, const key_type (*v_to_k)(const value_type))
+	explicit __base_associative(const Compare& comp, const Allocator& A, key_type (*v_to_k)(const value_type))
 		: c(comp), value_to_key(v_to_k) { }
 protected:
 	__base_associative(const associative_type& x)
@@ -318,7 +318,7 @@
 	typedef std::list<ValueType> listtype;
 
 	typename listtype::iterator base_iter;
-	typedef _associative_citer<ValueType, Compare, Allocator> _associative_citer;
+	typedef _associative_citer<ValueType, Compare, Allocator> __associative_citer;
 
 	
 public:
@@ -347,13 +347,13 @@
 	bool operator==(const _associative_iter & m) const{
 		return m.base_iter == base_iter;
 	}
-	bool operator==(const _associative_citer & m) const{
+	bool operator==(const __associative_citer & m) const{
 		return m.base_iter == base_iter;
 	}
 	bool operator!=(const _associative_iter & m) const{
 		return m.base_iter != base_iter;
 	}
-	bool operator!=(const _associative_citer & m) const{
+	bool operator!=(const __associative_citer & m) const{
 		return m.base_iter != base_iter;
 	}
 	_associative_iter & operator++(){
@@ -378,8 +378,8 @@
 		--base_iter;
 		return temp;
 	}
-	operator _associative_citer() const{
-		return _associative_citer(base_iter);
+	operator __associative_citer() const{
+		return __associative_citer(base_iter);
 	}
 	typename listtype::iterator base_iterator(){
 		return base_iter;
@@ -498,7 +498,7 @@
 	using base::operator==;
 	using base::operator!=;
 
-	explicit __single_associative(const Compare& comp, const Allocator& A, const key_type (*v_to_k)(const value_type))
+	explicit __single_associative(const Compare& comp, const Allocator& A, key_type (*v_to_k)(const value_type))
 		: base(comp, A, v_to_k) { }
 
 	template <class InputIterator> __single_associative(
@@ -506,7 +506,7 @@
 		InputIterator last,
 		const Compare& comp,
 		const Allocator& A,
-		const key_type (*v_to_k)(const value_type)
+		key_type (*v_to_k)(const value_type)
 	) : base(comp, A, v_to_k) {
 		insert(first, last);
 	}
--- a/include/string	Sun Jun  3 22:51:12 2007
+++ b/include/string	Sun Jan 11 21:50:18 2009
@@ -1017,11 +1017,11 @@
 
 template <> _UCXXEXPORT bool operator==(const string & lhs, const string & rhs);
 template <> _UCXXEXPORT bool operator==(const char * lhs, const string & rhs);
-template <> _UCXXEXPORT bool operator==(const string & rhs, const char * rhs);
+template <> _UCXXEXPORT bool operator==(const string & lhs, const char * rhs);
 
 template <> _UCXXEXPORT bool operator!=(const string & lhs, const string & rhs);
 template <> _UCXXEXPORT bool operator!=(const char * lhs, const string & rhs);
-template <> _UCXXEXPORT bool operator!=(const string & rhs, const char * rhs);
+template <> _UCXXEXPORT bool operator!=(const string & lhs, const char * rhs);
 
 template <> _UCXXEXPORT string operator+(const string & lhs, const char* rhs);
 template <> _UCXXEXPORT string operator+(const char* lhs, const string & rhs);
--- a/src/string.cpp	Sun Jun  3 22:51:13 2007
+++ b/src/string.cpp	Sun Jan 11 21:50:33 2009
@@ -76,11 +76,11 @@
 
 	template _UCXXEXPORT bool operator==(const string & lhs, const string & rhs);
 	template _UCXXEXPORT bool operator==(const char * lhs, const string & rhs);
-	template _UCXXEXPORT bool operator==(const string & rhs, const char * rhs);
+	template _UCXXEXPORT bool operator==(const string & lhs, const char * rhs);
 
 	template _UCXXEXPORT bool operator!=(const string & lhs, const string & rhs);
 	template _UCXXEXPORT bool operator!=(const char * lhs, const string & rhs);
-	template _UCXXEXPORT bool operator!=(const string & rhs, const char * rhs);
+	template _UCXXEXPORT bool operator!=(const string & lhs, const char * rhs);
 
 	template _UCXXEXPORT string operator+(const string & lhs, const char* rhs);
 	template _UCXXEXPORT string operator+(const char* lhs, const string & rhs);
