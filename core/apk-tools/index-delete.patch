commit 2b6e5d6e40a0b8a7ef650ef66996148cfdca1f2c
Author: Natanael Copa <ncopa@alpinelinux.org>
Date:   Tue May 12 06:27:25 2009 +0000

    index: support for -d to delete packages from given index
    
    The syntax is: apk index -d /path/to/APK_INDEX.gz pkg...
    
    It does not seem like its possible to remove packages in the db so we
    trick apk_db_index_write() by setting the repo to on-zero.
    
    It's still not perfect since it does not recalculate the dependencies.

diff --git a/src/apk_database.h b/src/apk_database.h
index e7bfac9..0a0e52d 100644
--- a/src/apk_database.h
+++ b/src/apk_database.h
@@ -123,6 +123,7 @@ struct apk_package *apk_db_pkg_add_file(struct apk_database *db, const char *fil
 struct apk_package *apk_db_get_pkg(struct apk_database *db, csum_t sum);
 struct apk_package *apk_db_get_file_owner(struct apk_database *db, apk_blob_t filename);
 
+int apk_db_index_read(struct apk_database *db, struct apk_istream *is, int repo);
 int apk_db_index_write(struct apk_database *db, struct apk_ostream *os);
 
 int apk_db_add_repository(apk_database_t db, apk_blob_t repository);
diff --git a/src/database.c b/src/database.c
index 4da547d..e91c64a 100644
--- a/src/database.c
+++ b/src/database.c
@@ -370,7 +370,7 @@ static struct apk_package *apk_db_pkg_add(struct apk_database *db, struct apk_pa
 	return idb;
 }
 
-static int apk_db_index_read(struct apk_database *db, struct apk_istream *is, int repo)
+int apk_db_index_read(struct apk_database *db, struct apk_istream *is, int repo)
 {
 	struct apk_package *pkg = NULL;
 	struct apk_db_dir_instance *diri = NULL;
diff --git a/src/index.c b/src/index.c
index 08fc342..e906ab4 100644
--- a/src/index.c
+++ b/src/index.c
@@ -19,6 +19,40 @@ struct counts {
 	int unsatisfied;
 };
 
+struct index_ctx {
+	const char *index_file;
+	int delete;
+};
+
+static int index_parse(void *ctx, int optch, int optindex, const char *optarg)
+{
+	struct index_ctx *ictx = (struct index_ctx *) ctx;
+
+	switch (optch) {
+	case 'd':
+		ictx->index_file = optarg;
+		ictx->delete = 1;
+		break;
+	default:
+		return -1;
+	}
+	return 0;
+}
+
+static int index_read_file(struct apk_database *db, struct index_ctx *ictx)
+{
+	struct apk_istream *is;
+	int r;
+	if (ictx->index_file == NULL)
+		return 0;
+	is = apk_bstream_gunzip(apk_bstream_from_url(ictx->index_file), 1);
+	if (is == NULL)
+		return -1;
+	r = apk_db_index_read(db, is, -1);
+	is->close(is);
+	return r;
+}
+
 static int warn_if_no_providers(apk_hash_item item, void *ctx)
 {
 	struct counts *counts = (struct counts *) ctx;
@@ -42,11 +76,26 @@ static int index_main(void *ctx, int argc, char **argv)
 	struct apk_database db;
 	struct counts counts = {0};
 	struct apk_ostream *os;
-	int total, i;
+	int total, i, j;
+	struct index_ctx *ictx = (struct index_ctx *) ctx;
 
 	apk_db_open(&db, NULL, APK_OPENF_READ);
-	for (i = 0; i < argc; i++)
-		apk_db_pkg_add_file(&db, argv[i]);
+	index_read_file(&db, ictx);
+
+	for (i = 0; i < argc; i++) {
+		if (ictx->delete) {
+			struct apk_name *name;
+			name = apk_db_query_name(&db, APK_BLOB_STR(argv[i]));
+			if (name == NULL)
+				continue;
+			/* apk_db_index_write() will only print the pkgs
+			   where repos == 0. We prevent to write the given
+			   packages by setting repos to non-zero */
+			for (j = 0; j < name->pkgs->num; j++)
+				name->pkgs->item[j]->repos = -1;
+		} else
+			apk_db_pkg_add_file(&db, argv[i]);
+	}
 
 	os = apk_ostream_to_fd(STDOUT_FILENO);
 	total = apk_db_index_write(&db, os);
@@ -64,9 +113,17 @@ static int index_main(void *ctx, int argc, char **argv)
 	return 0;
 }
 
+static struct option index_options[] = {
+	{ "delete",	required_argument,	NULL, 'd' },
+};
+
 static struct apk_applet apk_index = {
 	.name = "index",
-	.usage = "apkname...",
+	.usage = "[-d indexfile] apkname...",
+	.context_size = sizeof(struct index_ctx),
+	.num_options = ARRAY_SIZE(index_options),
+	.options = index_options,
+	.parse = index_parse,
 	.main = index_main,
 };
 
