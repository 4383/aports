Index: libm/s_finite.c
===================================================================
--- libm/s_finite.c	(revision 24488)
+++ libm/s_finite.c	(revision 24489)
@@ -25,5 +25,3 @@
 	return (int)((u_int32_t)((hx&0x7fffffff)-0x7ff00000)>>31);
 }
 libm_hidden_def(__finite)
-weak_alias(__finite,finite)
-libm_hidden_weak(finite)
Index: libm/s_isinff.c
===================================================================
--- libm/s_isinff.c	(revision 24488)
+++ libm/s_isinff.c	(revision 24489)
@@ -11,7 +11,6 @@
 #include "math.h"
 #include "math_private.h"
 
-libm_hidden_proto(__isinff)
 int
 __isinff (float x)
 {
@@ -23,4 +22,3 @@
 	return ~(t >> 31) & (ix >> 30);
 }
 libm_hidden_def(__isinff)
-strong_alias (__isinff, isinff)
Index: libm/Makefile.in
===================================================================
--- libm/Makefile.in	(revision 24488)
+++ libm/Makefile.in	(revision 24489)
@@ -86,13 +86,13 @@
 	scalblnf.o scalbnf.o sinf.o sinhf.o sqrtf.o tanf.o tanhf.o \
 	tgammaf.o truncf.o cargf.o llrintf.o
 
-LD_MOBJ := acoshl.o acosl.o asinhl.o asinl.o atan2l.o atanhl.o atanl.o cbrtl.o \
+LD_MOBJ := acoshl.o acosl.o asinhl.o asinl.o atan2l.o atanhl.o atanl.o cargl.o cbrtl.o \
 	ceill.o copysignl.o coshl.o cosl.o erfcl.o erfl.o exp2l.o expl.o \
-	expm1l.o fabsl.o fdiml.o floorl.o fmal.o fmaxl.o fminl.o fmodl.o \
-	frexpl.o gammal.o hypotl.o ilogbl.o ldexpl.o lgammal.o llrintl.o \
+	expm1l.o fabsl.o finitel.o fdiml.o floorl.o fmal.o fmaxl.o fminl.o fmodl.o fpclassifyl.o \
+	frexpl.o gammal.o hypotl.o ilogbl.o isinfl.o isnanl.o ldexpl.o lgammal.o llrintl.o \
 	llroundl.o log10l.o log1pl.o XXXlog2l.o logbl.o logl.o lrintl.o lroundl.o \
 	modfl.o nearbyintl.o nextafterl.o XXXnexttowardl.o powl.o remainderl.o \
-	remquol.o rintl.o roundl.o scalblnl.o scalbnl.o sinhl.o sinl.o sqrtl.o \
+	remquol.o rintl.o roundl.o scalblnl.o scalbnl.o signbitl.o sinhl.o sinl.o sqrtl.o \
 	tanhl.o tanl.o tgammal.o truncl.o
 else
 # This list of math functions was taken from POSIX/IEEE 1003.1b-1993
@@ -139,21 +139,21 @@
 libm_OBJ := $(patsubst $(libm_DIR)/%.c,$(libm_OUT)/%.o,$(libm_SRC))
 
 ifeq ($(strip $(UCLIBC_HAS_LONG_DOUBLE_MATH)),y)
-libm_MSRC2 := $(libm_DIR)/$(LD_MSRC)
-libm_MOBJ2 := $(patsubst %.o,$(libm_OUT)/%.o,$(LD_MOBJ))
+libm_MSRC_LD := $(libm_DIR)/$(LD_MSRC)
+libm_MOBJ_LD := $(patsubst %.o,$(libm_OUT)/%.o,$(LD_MOBJ))
 endif
-libm_MSRC := $(libm_DIR)/$(FL_MSRC)
-libm_MOBJ := $(patsubst %.o,$(libm_OUT)/%.o,$(FL_MOBJ))
+libm_MSRC_FL := $(libm_DIR)/$(FL_MSRC)
+libm_MOBJ_FL := $(patsubst %.o,$(libm_OUT)/%.o,$(FL_MOBJ))
 
 
 ifneq ($(DOMULTI),n)
-CFLAGS-libm += $(patsubst %,-DL_%,$(subst .o,,$(notdir $(libm_MOBJ))))
+CFLAGS-libm += $(patsubst %,-DL_%,$(subst .o,,$(notdir $(libm_MOBJ_FL))))
 ifeq ($(strip $(UCLIBC_HAS_LONG_DOUBLE_MATH)),y)
-CFLAGS-libm += $(patsubst %,-DL_%,$(subst .o,,$(notdir $(libm_MOBJ2))))
+CFLAGS-libm += $(patsubst %,-DL_%,$(subst .o,,$(notdir $(libm_MOBJ_LD))))
 endif
 endif
 
-libm_OBJS := $(libm_OBJ) $(libm_MOBJ) $(libm_MOBJ2)
+libm_OBJS := $(libm_OBJ) $(libm_MOBJ_FL) $(libm_MOBJ_LD)
 
 ifeq ($(DOPIC),y)
 libm-a-y += $(libm_OBJS:.o=.os)
@@ -182,7 +182,7 @@
 	$(Q)$(RM) $@
 	$(do_ar)
 
-$(libm_OUT)/libm.oS: $(libm_SRC) $(libm_MSRC) $(libm_MSRC2) $(libm_ARCH_SRC)
+$(libm_OUT)/libm.oS: $(libm_SRC) $(libm_MSRC_FL) $(libm_MSRC_LD) $(libm_ARCH_SRC)
 	$(Q)$(RM) $@
 	$(compile-m)
 
@@ -191,17 +191,24 @@
 	$(Q)$(RM) $@
 	$(do_ar)
 
-$(libm_MOBJ): $(libm_MSRC)
+$(libm_MOBJ_FL): $(libm_MSRC_FL)
 	$(compile.m)
 
-$(libm_MOBJ2): $(libm_MSRC2)
+$(libm_MOBJ_LD): $(libm_MSRC_LD)
 	$(compile.m)
 
-$(libm_MOBJ:.o=.os): $(libm_MSRC)
+$(libm_MOBJ_FL:.o=.os): $(libm_MSRC_FL)
 	$(compile.m)
 
-$(libm_MOBJ2:.o=.os): $(libm_MSRC2)
+$(libm_MOBJ_LD:.o=.os): $(libm_MSRC_LD)
 	$(compile.m)
 
+# spare us from adding a gazillion dummy two-liner files
+$(libm_MOBJ_FL:.o=.i): $(libm_MSRC_FL)
+	$(compile.mi)
+
+$(libm_MOBJ_LD:.o=.i): $(libm_MSRC_LD)
+	$(compile.mi)
+
 libm_clean:
 	$(do_rm) $(addprefix $(libm_OUT)/,$(foreach e, o os oS a,$(foreach d, *. */*. */*/*.,$(d)$(e))))
Index: libm/s_finitef.c
===================================================================
--- libm/s_finitef.c	(revision 24488)
+++ libm/s_finitef.c	(revision 24489)
@@ -21,7 +21,6 @@
 #include "math.h"
 #include "math_private.h"
 
-libm_hidden_proto(__finitef)
 int __finitef(float x)
 {
 	int32_t ix;
@@ -29,4 +28,3 @@
 	return (int)((u_int32_t)((ix&0x7fffffff)-0x7f800000)>>31);
 }
 libm_hidden_def(__finitef)
-strong_alias(__finitef,finitef)
Index: libm/ldouble_wrappers.c
===================================================================
--- libm/ldouble_wrappers.c	(revision 24488)
+++ libm/ldouble_wrappers.c	(revision 24489)
@@ -11,7 +11,9 @@
  */
 
 #include "math.h"
+#include <complex.h>
 
+
 /* Implement the following, as defined by SuSv3 */
 #if 0
 long double acoshl(long double);
@@ -21,6 +23,7 @@
 long double atan2l(long double, long double);
 long double atanhl(long double);
 long double atanl(long double);
+long double cargl(long double complex);
 long double cbrtl(long double);
 long double ceill(long double);
 long double copysignl(long double, long double);
@@ -128,6 +131,14 @@
 #endif
 
 
+#ifdef L_cargl
+long double cargl (long double complex x)
+{
+	return (long double) carg( (double complex)x );
+}
+#endif
+
+
 #ifdef L_cbrtl
 long double cbrtl (long double x)
 {
@@ -521,3 +532,48 @@
 	return (long double) trunc( (double)x );
 }
 #endif
+
+
+#ifdef __DO_C99_MATH__
+
+#ifdef L_fpclassifyl
+int __fpclassifyl (long double x)
+{
+	return __fpclassify ( (double) x );
+}
+libm_hidden_def(__fpclassifyl)
+#endif
+
+#ifdef L_finitel
+int __finitel (long double x)
+{
+	return __finite ( (double)x );
+}
+libm_hidden_def(__finitel)
+#endif
+
+#ifdef L_signbitl
+int __signbitl (long double x)
+{
+	return __signbitl ( (double)x );
+}
+libm_hidden_def(__signbitl)
+#endif
+
+#ifdef L_isnanl
+int __isnanl (long double x)
+{
+	return __isnan ( (double)x );
+}
+libm_hidden_def(__isnanl)
+#endif
+
+#ifdef L_isinfl
+int __isinfl (long double x)
+{
+	return __isinf ( (double)x );
+}
+libm_hidden_def(__isinfl)
+#endif
+
+#endif
Index: libm/w_exp.c
===================================================================
--- libm/w_exp.c	(revision 24488)
+++ libm/w_exp.c	(revision 24489)
@@ -42,7 +42,7 @@
 	double z;
 	z = __ieee754_exp(x);
 	if(_LIB_VERSION == _IEEE_) return z;
-	if(finite(x)) {
+	if(isfinite(x)) {
 	    if(x>o_threshold)
 	        return __kernel_standard(x,x,6); /* exp overflow */
 	    else if(x<u_threshold)
Index: libm/s_fma.c
===================================================================
--- libm/s_fma.c	(revision 24488)
+++ libm/s_fma.c	(revision 24489)
@@ -20,11 +20,9 @@
 
 #include <math.h>
 
-libm_hidden_proto(__fma)
 double
-__fma (double x, double y, double z)
+fma (double x, double y, double z)
 {
   return (x * y) + z;
 }
-libm_hidden_def(__fma)
-strong_alias (__fma, fma)
+libm_hidden_def(fma)
Index: libm/s_signbitf.c
===================================================================
--- libm/s_signbitf.c	(revision 24488)
+++ libm/s_signbitf.c	(revision 24489)
@@ -22,7 +22,6 @@
 
 #include "math_private.h"
 
-libm_hidden_proto(__signbitf)
 int
 __signbitf (float x)
 {
Index: libm/w_log2.c
===================================================================
--- libm/w_log2.c	(revision 24488)
+++ libm/w_log2.c	(revision 24489)
@@ -11,4 +11,3 @@
 {
 	return __ieee754_log2 (d);
 }
-libm_hidden_def(log2)
Index: libm/w_jn.c
===================================================================
--- libm/w_jn.c	(revision 24488)
+++ libm/w_jn.c	(revision 24489)
@@ -62,7 +62,6 @@
 	    return z;
 #endif
 }
-libm_hidden_def(jn)
 
 #ifdef __STDC__
 	double yn(int n, double x)	/* wrapper yn */
@@ -91,4 +90,3 @@
 	    return z;
 #endif
 }
-libm_hidden_def(yn)
Index: libm/w_j1.c
===================================================================
--- libm/w_j1.c	(revision 24488)
+++ libm/w_j1.c	(revision 24489)
@@ -40,7 +40,6 @@
 	    return z;
 #endif
 }
-libm_hidden_def(j1)
 
 #ifdef __STDC__
 	double y1(double x)		/* wrapper y1 */
@@ -69,4 +68,3 @@
 	    return z;
 #endif
 }
-libm_hidden_def(y1)
Index: libm/s_isnanf.c
===================================================================
--- libm/s_isnanf.c	(revision 24488)
+++ libm/s_isnanf.c	(revision 24489)
@@ -21,7 +21,6 @@
 #include "math.h"
 #include "math_private.h"
 
-libm_hidden_proto (__isnanf)
 int __isnanf(float x)
 {
 	int32_t ix;
@@ -30,5 +29,4 @@
 	ix = 0x7f800000 - ix;
 	return (int)(((u_int32_t)(ix))>>31);
 }
-libm_hidden_def (__isnanf)
-weak_alias (__isnanf, isnanf)
+libm_hidden_def(__isnanf)
Index: libm/w_lgamma_r.c
===================================================================
--- libm/w_lgamma_r.c	(revision 24488)
+++ libm/w_lgamma_r.c	(revision 24489)
@@ -34,7 +34,7 @@
         double y;
         y = __ieee754_lgamma_r(x,signgamp);
         if(_LIB_VERSION == _IEEE_) return y;
-        if(!finite(y)&&finite(x)) {
+        if(!isfinite(y)&&isfinite(x)) {
             if(floor(x)==x&&x<=0.0)
                 return __kernel_standard(x,x,15); /* lgamma pole */
             else
@@ -43,4 +43,3 @@
             return y;
 #endif
 }
-libm_hidden_def(lgamma_r)
Index: libm/w_hypot.c
===================================================================
--- libm/w_hypot.c	(revision 24488)
+++ libm/w_hypot.c	(revision 24489)
@@ -34,7 +34,7 @@
 	double z;
 	z = __ieee754_hypot(x,y);
 	if(_LIB_VERSION == _IEEE_) return z;
-	if((!finite(z))&&finite(x)&&finite(y))
+	if((!isfinite(z))&&isfinite(x)&&isfinite(y))
 	    return __kernel_standard(x,y,4); /* hypot overflow */
 	else
 	    return z;
Index: libm/s_isinf.c
===================================================================
--- libm/s_isinf.c	(revision 24488)
+++ libm/s_isinf.c	(revision 24489)
@@ -22,5 +22,3 @@
 	return ~(lx >> 31) & (hx >> 30);
 }
 libm_hidden_def(__isinf)
-weak_alias (__isinf, isinf)
-libm_hidden_weak(isinf)
Index: libm/s_significand.c
===================================================================
--- libm/s_significand.c	(revision 24488)
+++ libm/s_significand.c	(revision 24489)
@@ -33,4 +33,3 @@
 {
 	return __ieee754_scalb(x,(double) -ilogb(x));
 }
-libm_hidden_def(significand)
Index: libm/w_gamma.c
===================================================================
--- libm/w_gamma.c	(revision 24488)
+++ libm/w_gamma.c	(revision 24489)
@@ -37,7 +37,7 @@
         double y;
         y = __ieee754_lgamma_r(x,&signgam);
         if(_LIB_VERSION == _IEEE_) return y;
-        if(!finite(y)&&finite(x)) {
+        if(!isfinite(y)&&isfinite(x)) {
             if(floor(x)==x&&x<=0.0)
                 return __kernel_standard(x,x,41); /* gamma pole */
             else
@@ -46,4 +46,3 @@
             return y;
 #endif
 }
-libm_hidden_def(gamma)
Index: libm/w_drem.c
===================================================================
--- libm/w_drem.c	(revision 24488)
+++ libm/w_drem.c	(revision 24489)
@@ -12,4 +12,3 @@
 {
 	return remainder(x, y);
 }
-libm_hidden_def(drem)
Index: libm/s_fpclassify.c
===================================================================
--- libm/s_fpclassify.c	(revision 24488)
+++ libm/s_fpclassify.c	(revision 24489)
@@ -40,4 +40,4 @@
 
   return retval;
 }
-libm_hidden_def (__fpclassify)
+libm_hidden_def(__fpclassify)
Index: libm/w_sinh.c
===================================================================
--- libm/w_sinh.c	(revision 24488)
+++ libm/w_sinh.c	(revision 24489)
@@ -34,7 +34,7 @@
 	double z;
 	z = __ieee754_sinh(x);
 	if(_LIB_VERSION == _IEEE_) return z;
-	if(!finite(z)&&finite(x)) {
+	if(!isfinite(z)&&isfinite(x)) {
 	    return __kernel_standard(x,x,25); /* sinh overflow */
 	} else
 	    return z;
Index: libm/e_scalb.c
===================================================================
--- libm/e_scalb.c	(revision 24488)
+++ libm/e_scalb.c	(revision 24489)
@@ -44,7 +44,7 @@
 	return scalbn(x,fn);
 #else
 	if (isnan(x)||isnan(fn)) return x*fn;
-	if (!finite(fn)) {
+	if (!isfinite(fn)) {
 	    if(fn>0.0) return x*fn;
 	    else       return x/(-fn);
 	}
Index: libm/float_wrappers.c
===================================================================
--- libm/float_wrappers.c	(revision 24488)
+++ libm/float_wrappers.c	(revision 24489)
@@ -36,6 +36,7 @@
 float       atan2f(float, float);
 float       atanf(float);
 float       atanhf(float);
+float       cargf(float complex);
 float       cbrtf(float);
 float       ceilf(float);
 float       copysignf(float, float);
@@ -133,7 +134,7 @@
 #ifdef L_cargf
 float cargf (float complex x)
 {
-	return (float) carg( (double)x );
+	return (float) carg( (double complex)x );
 }
 #endif
 
@@ -532,3 +533,10 @@
 	return (float) trunc( (double)x );
 }
 #endif
+
+#ifdef L_fmaf
+float fmaf (float x, float y, float z)
+{
+	return (float) fma( (double)x, (double)y, (double)z );
+}
+#endif
Index: libm/s_isnan.c
===================================================================
--- libm/s_isnan.c	(revision 24488)
+++ libm/s_isnan.c	(revision 24489)
@@ -18,12 +18,7 @@
 #include "math.h"
 #include "math_private.h"
 
-#ifdef __STDC__
-	int __isnan(double x)
-#else
-	int __isnan(x)
-	double x;
-#endif
+int __isnan(double x)
 {
 	int32_t hx,lx;
 	EXTRACT_WORDS(hx,lx,x);
@@ -33,5 +28,3 @@
 	return (int)(((u_int32_t)hx)>>31);
 }
 libm_hidden_def(__isnan)
-weak_alias(__isnan,isnan)
-libm_hidden_weak(isnan)
Index: libm/s_ldexp.c
===================================================================
--- libm/s_ldexp.c	(revision 24488)
+++ libm/s_ldexp.c	(revision 24489)
@@ -26,9 +26,9 @@
 	double value; int exp;
 #endif
 {
-	if(!finite(value)||value==0.0) return value;
+	if(!isfinite(value)||value==0.0) return value;
 	value = scalbn(value,exp);
-	if(!finite(value)||value==0.0) errno = ERANGE;
+	if(!isfinite(value)||value==0.0) errno = ERANGE;
 	return value;
 }
 libm_hidden_def(ldexp)
Index: libm/w_j0.c
===================================================================
--- libm/w_j0.c	(revision 24488)
+++ libm/w_j0.c	(revision 24489)
@@ -39,7 +39,6 @@
 	    return z;
 #endif
 }
-libm_hidden_def(j0)
 
 #ifdef __STDC__
 	double y0(double x)		/* wrapper y0 */
@@ -68,4 +67,3 @@
 	    return z;
 #endif
 }
-libm_hidden_def(y0)
Index: libm/w_scalb.c
===================================================================
--- libm/w_scalb.c	(revision 24488)
+++ libm/w_scalb.c	(revision 24489)
@@ -46,16 +46,15 @@
 	double z;
 	z = __ieee754_scalb(x,fn);
 	if(_LIB_VERSION == _IEEE_) return z;
-	if(!(finite(z)||isnan(z))&&finite(x)) {
+	if(!(isfinite(z)||isnan(z))&&isfinite(x)) {
 	    return __kernel_standard(x,(double)fn,32); /* scalb overflow */
 	}
 	if(z==0.0&&z!=x) {
 	    return __kernel_standard(x,(double)fn,33); /* scalb underflow */
 	}
 #ifndef _SCALB_INT
-	if(!finite(fn)) errno = ERANGE;
+	if(!isfinite(fn)) errno = ERANGE;
 #endif
 	return z;
 #endif
 }
-libm_hidden_def(scalb)
Index: libm/w_lgamma.c
===================================================================
--- libm/w_lgamma.c	(revision 24488)
+++ libm/w_lgamma.c	(revision 24489)
@@ -37,7 +37,7 @@
         double y;
         y = __ieee754_lgamma_r(x,&signgam);
         if(_LIB_VERSION == _IEEE_) return y;
-        if(!finite(y)&&finite(x)) {
+        if(!isfinite(y)&&isfinite(x)) {
             if(floor(x)==x&&x<=0.0)
                 return __kernel_standard(x,x,15); /* lgamma pole */
             else
Index: libm/w_gamma_r.c
===================================================================
--- libm/w_gamma_r.c	(revision 24488)
+++ libm/w_gamma_r.c	(revision 24489)
@@ -37,7 +37,7 @@
         double y;
         y = __ieee754_lgamma_r(x,signgamp);
         if(_LIB_VERSION == _IEEE_) return y;
-        if(!finite(y)&&finite(x)) {
+        if(!isfinite(y)&&isfinite(x)) {
             if(floor(x)==x&&x<=0.0)
                 return __kernel_standard(x,x,41); /* gamma pole */
             else
Index: libm/s_fpclassifyf.c
===================================================================
--- libm/s_fpclassifyf.c	(revision 24488)
+++ libm/s_fpclassifyf.c	(revision 24489)
@@ -21,9 +21,7 @@
 #include <math.h>
 #include "math_private.h"
 
-libm_hidden_proto (__fpclassifyf)
-int
-__fpclassifyf (float x)
+int __fpclassifyf (float x)
 {
   u_int32_t wx;
   int retval = FP_NORMAL;
@@ -39,4 +37,4 @@
 
   return retval;
 }
-libm_hidden_def (__fpclassifyf)
+libm_hidden_def(__fpclassifyf)
Index: libm/w_pow.c
===================================================================
--- libm/w_pow.c	(revision 24488)
+++ libm/w_pow.c	(revision 24489)
@@ -41,19 +41,19 @@
 	if(x==0.0){
 	    if(y==0.0)
 	        return __kernel_standard(x,y,20); /* pow(0.0,0.0) */
-	    if(finite(y)&&y<0.0)
+	    if(isfinite(y)&&y<0.0)
 	        return __kernel_standard(x,y,23); /* pow(0.0,negative) */
 	    return z;
 	}
-	if(!finite(z)) {
-	    if(finite(x)&&finite(y)) {
+	if(!isfinite(z)) {
+	    if(isfinite(x)&&isfinite(y)) {
 	        if(isnan(z))
 	            return __kernel_standard(x,y,24); /* pow neg**non-int */
 	        else
 	            return __kernel_standard(x,y,21); /* pow overflow */
 	    }
 	}
-	if(z==0.0&&finite(x)&&finite(y))
+	if(z==0.0&&isfinite(x)&&isfinite(y))
 	    return __kernel_standard(x,y,22); /* pow underflow */
 	return z;
 #endif
Index: libm/w_tgamma.c
===================================================================
--- libm/w_tgamma.c	(revision 24488)
+++ libm/w_tgamma.c	(revision 24489)
@@ -35,7 +35,7 @@
 #else
 	if(_LIB_VERSION == _IEEE_) return y;
 
-	if(!finite(y)&&finite(x)) {
+	if(!isfinite(y)&&isfinite(x)) {
 	  if(floor(x)==x&&x<=0.0)
 	    return __kernel_standard(x,x,41); /* tgamma pole */
 	  else
Index: include/math.h
===================================================================
--- include/math.h	(revision 24488)
+++ include/math.h	(revision 24489)
@@ -46,6 +46,10 @@
 /* Get general and ISO C99 specific information.  */
 #include <bits/mathdef.h>
 
+#if !(defined _LIBC && (defined NOT_IN_libc && defined IS_IN_libm))
+# define libm_hidden_proto(name, attrs...)
+#endif
+
 /* The file <bits/mathcalls.h> contains the prototypes for all the
    actual math functions.  These macros are used for those prototypes,
    so we can easily declare each function as both `name' and `__name',
@@ -54,16 +58,30 @@
 #define __MATHCALL(function,suffix, args)	\
   __MATHDECL (_Mdouble_,function,suffix, args)
 #define __MATHDECL(type, function,suffix, args) \
-  __MATHDECL_1(type, function,suffix, args); \
-  __MATHDECL_1(type, __CONCAT(__,function),suffix, args)
+  __MATHDECL_1(type, function,suffix, args);
 #define __MATHCALLX(function,suffix, args, attrib)	\
   __MATHDECLX (_Mdouble_,function,suffix, args, attrib)
 #define __MATHDECLX(type, function,suffix, args, attrib) \
   __MATHDECL_1(type, function,suffix, args) __attribute__ (attrib); \
-  __MATHDECL_1(type, __CONCAT(__,function),suffix, args) __attribute__ (attrib)
+  __MATHDECLI_MAINVARIANT(function)
 #define __MATHDECL_1(type, function,suffix, args) \
   extern type __MATH_PRECNAME(function,suffix) args __THROW
+/* Decls which are also used internally in libm.
+   Only the main variant is used internally, no need to try to avoid relocs
+   for the {l,f} variants.  */
+#define __MATHCALLI(function,suffix, args)	\
+  __MATHDECLI (_Mdouble_,function,suffix, args)
+#define __MATHDECLI(type, function,suffix, args) \
+  __MATHDECL_1(type, function,suffix, args); \
+  __MATHDECLI_MAINVARIANT(function)
+/* Private helpers for purely macro impls below.
+   Only make __foo{,f,l} visible but not (the macro-only) foo.  */
+#define __MATHDECL_PRIV(type, function,suffix, args, attrib) \
+  __MATHDECL_1(type, __CONCAT(__,function),suffix, args) \
+						__attribute__ (attrib); \
+  libm_hidden_proto(__MATH_PRECNAME(__##function,suffix))
 
+#define __MATHDECLI_MAINVARIANT libm_hidden_proto
 #define _Mdouble_		double
 #define __MATH_PRECNAME(name,r)	__CONCAT(name,r)
 # define _Mdouble_BEGIN_NAMESPACE __BEGIN_NAMESPACE_STD
@@ -72,7 +90,9 @@
 #undef	_Mdouble_
 #undef _Mdouble_BEGIN_NAMESPACE
 #undef _Mdouble_END_NAMESPACE
-#undef	__MATH_PRECNAME
+#undef __MATH_PRECNAME
+#undef __MATHDECLI_MAINVARIANT
+#define __MATHDECLI_MAINVARIANT(x)
 
 #if defined __USE_MISC || defined __USE_ISOC99
 
Index: Makerules
===================================================================
--- Makerules	(revision 24488)
+++ Makerules	(revision 24489)
@@ -80,6 +80,7 @@
 pur_disp_compile.u = echo "  "CC $(show_objs)
 pur_disp_compile.S = echo "  "AS $(show_objs)
 pur_disp_compile.m = $(pur_disp_compile.c)
+pur_disp_compile.mi= echo "  "CPP-m $(show_objs)
 pur_disp_compile-m = echo "  "CC-m $(show_objs)
 pur_disp_hcompile.u= echo "  "HOSTCC $(show_objs)
 pur_disp_hcompile.o= echo "  "HOSTCC-o $(show_objs)
@@ -99,6 +100,7 @@
 sil_disp_compile.u = true
 sil_disp_compile.S = true
 sil_disp_compile.m = true
+sil_disp_compile.mi= true
 sil_disp_compile-m = true
 sil_disp_hcompile.u= true
 sil_disp_hcompile.o= true
@@ -118,6 +120,7 @@
 ver_disp_compile.u = echo $(cmd_compile.u)
 ver_disp_compile.S = echo $(cmd_compile.S)
 ver_disp_compile.m = echo $(cmd_compile.m)
+ver_disp_compile.mi= echo $(cmd_compile.mi)
 ver_disp_compile-m = echo $(cmd_compile-m)
 ver_disp_hcompile.u= echo $(cmd_hcompile.u)
 ver_disp_hcompile.o= echo $(cmd_hcompile.o)
@@ -137,6 +140,7 @@
 disp_compile.u = $($(DISP)_disp_compile.u)
 disp_compile.S = $($(DISP)_disp_compile.S)
 disp_compile.m = $($(DISP)_disp_compile.m)
+disp_compile.mi= $($(DISP)_disp_compile.mi)
 disp_compile-m = $($(DISP)_disp_compile-m)
 disp_hcompile.u= $($(DISP)_disp_hcompile.u)
 disp_hcompile.o= $($(DISP)_disp_hcompile.o)
@@ -189,6 +193,7 @@
 cmd_compile.u = $(CC) $^ $(DEPS-$(notdir $@)) -o $@ $(CFLAGS) $(CFLAGS-$(notdir $(^D))) $(CFLAGS-$(notdir $@)) $(CFLAGS_gen.dep)
 cmd_compile.S = $(filter-out -std=gnu99, $(cmd_compile.c)) -D__ASSEMBLER__ $(ASFLAGS) $(ARCH_ASFLAGS) $(ASFLAGS-$(suffix $@)) $(ASFLAGS-$(notdir $<)) $(ASFLAGS-$(notdir $@))
 cmd_compile.m = $(cmd_compile.c) -DL_$(patsubst %$(suffix $(notdir $@)),%,$(notdir $@))
+cmd_compile.mi= $(cmd_compile.m:-c=-E -dD $(EXTRA_CPPFLAGS))
 
 cmd_compile-m = $(CC) $^ -c -o $@ $(CFLAGS) $(ARCH_CFLAGS) $(CFLAGS-$(suffix $@)) $(CFLAGS-$(notdir $(@D))) $(CFLAGS-$(notdir $@))
 cmd_strip     = $(STRIPTOOL) $(STRIP_FLAGS) $^
@@ -211,7 +216,8 @@
 compile.s =  $(call maybe_exec,compile.s)
 compile.S = @$(call maybe_exec,compile.S)
 compile.m = @$(call maybe_exec,compile.m)
-compile-m = @$(disp_compile-m) ; $(cmd_compile-m) ; $(cmd_t_strip)
+compile.mi=  $(call maybe_exec,compile.mi)
+compile-m = @$(disp_compile-m) ; $(cmd_compile-m) && $(cmd_t_strip)
 do_strip  = @$(disp_strip)     ; $(cmd_strip)
 do_t_strip= @$(disp_t_strip)   ; $(cmd_t_strip)
 do_unifdef= @$(disp_unifdef)   ; $(cmd_unifdef)
Index: libc/sysdeps/linux/common/bits/mathcalls.h
===================================================================
--- libc/sysdeps/linux/common/bits/mathcalls.h	(revision 24488)
+++ libc/sysdeps/linux/common/bits/mathcalls.h	(revision 24489)
@@ -52,59 +52,45 @@
 
 _Mdouble_BEGIN_NAMESPACE
 /* Arc cosine of X.  */
-__MATHCALL (acos,, (_Mdouble_ __x));
-libm_hidden_proto(acos)
+__MATHCALLI (acos,, (_Mdouble_ __x));
 /* Arc sine of X.  */
-__MATHCALL (asin,, (_Mdouble_ __x));
-libm_hidden_proto(asin)
+__MATHCALLI (asin,, (_Mdouble_ __x));
 /* Arc tangent of X.  */
-__MATHCALL (atan,, (_Mdouble_ __x));
-libm_hidden_proto(atan)
+__MATHCALLI (atan,, (_Mdouble_ __x));
 /* Arc tangent of Y/X.  */
-__MATHCALL (atan2,, (_Mdouble_ __y, _Mdouble_ __x));
-libm_hidden_proto(atan2)
+__MATHCALLI (atan2,, (_Mdouble_ __y, _Mdouble_ __x));
 
 /* Cosine of X.  */
-__MATHCALL (cos,, (_Mdouble_ __x));
-libm_hidden_proto(cos)
+__MATHCALLI (cos,, (_Mdouble_ __x));
 /* Sine of X.  */
-__MATHCALL (sin,, (_Mdouble_ __x));
-libm_hidden_proto(sin)
+__MATHCALLI (sin,, (_Mdouble_ __x));
 /* Tangent of X.  */
-__MATHCALL (tan,, (_Mdouble_ __x));
-libm_hidden_proto(tan)
+__MATHCALLI (tan,, (_Mdouble_ __x));
 
 /* Hyperbolic functions.  */
 
 /* Hyperbolic cosine of X.  */
-__MATHCALL (cosh,, (_Mdouble_ __x));
-libm_hidden_proto(cosh)
+__MATHCALLI (cosh,, (_Mdouble_ __x));
 /* Hyperbolic sine of X.  */
-__MATHCALL (sinh,, (_Mdouble_ __x));
-libm_hidden_proto(sinh)
+__MATHCALLI (sinh,, (_Mdouble_ __x));
 /* Hyperbolic tangent of X.  */
-__MATHCALL (tanh,, (_Mdouble_ __x));
-libm_hidden_proto(tanh)
+__MATHCALLI (tanh,, (_Mdouble_ __x));
 _Mdouble_END_NAMESPACE
 
 #if 0 /*def __USE_GNU*/
 /* Cosine and sine of X.  */
 __MATHDECL (void,sincos,,
 	    (_Mdouble_ __x, _Mdouble_ *__sinx, _Mdouble_ *__cosx));
-libm_hidden_proto(sincos)
 #endif
 
 #if defined __USE_MISC || defined __USE_XOPEN_EXTENDED || defined __USE_ISOC99
 __BEGIN_NAMESPACE_C99
 /* Hyperbolic arc cosine of X.  */
-__MATHCALL (acosh,, (_Mdouble_ __x));
-libm_hidden_proto(acosh)
+__MATHCALLI (acosh,, (_Mdouble_ __x));
 /* Hyperbolic arc sine of X.  */
-__MATHCALL (asinh,, (_Mdouble_ __x));
-libm_hidden_proto(asinh)
+__MATHCALLI (asinh,, (_Mdouble_ __x));
 /* Hyperbolic arc tangent of X.  */
-__MATHCALL (atanh,, (_Mdouble_ __x));
-libm_hidden_proto(atanh)
+__MATHCALLI (atanh,, (_Mdouble_ __x));
 __END_NAMESPACE_C99
 #endif
 
@@ -112,64 +98,51 @@
 
 _Mdouble_BEGIN_NAMESPACE
 /* Exponential function of X.  */
-__MATHCALL (exp,, (_Mdouble_ __x));
-libm_hidden_proto(exp)
+__MATHCALLI (exp,, (_Mdouble_ __x));
 
 /* Break VALUE into a normalized fraction and an integral power of 2.  */
-__MATHCALL (frexp,, (_Mdouble_ __x, int *__exponent));
-libm_hidden_proto(frexp)
+__MATHCALLI (frexp,, (_Mdouble_ __x, int *__exponent));
 
 /* X times (two to the EXP power).  */
-__MATHCALL (ldexp,, (_Mdouble_ __x, int __exponent));
-libm_hidden_proto(ldexp)
+__MATHCALLI (ldexp,, (_Mdouble_ __x, int __exponent));
 
 /* Natural logarithm of X.  */
-__MATHCALL (log,, (_Mdouble_ __x));
-libm_hidden_proto(log)
+__MATHCALLI (log,, (_Mdouble_ __x));
 
 /* Base-ten logarithm of X.  */
-__MATHCALL (log10,, (_Mdouble_ __x));
-libm_hidden_proto(log10)
+__MATHCALLI (log10,, (_Mdouble_ __x));
 
 /* Break VALUE into integral and fractional parts.  */
-__MATHCALL (modf,, (_Mdouble_ __x, _Mdouble_ *__iptr));
-libm_hidden_proto(modf)
+__MATHCALLI (modf,, (_Mdouble_ __x, _Mdouble_ *__iptr));
 _Mdouble_END_NAMESPACE
 
 #if 0 /*def __USE_GNU*/
 /* A function missing in all standards: compute exponent to base ten.  */
 __MATHCALL (exp10,, (_Mdouble_ __x));
-libm_hidden_proto(exp10)
 /* Another name occasionally used.  */
 __MATHCALL (pow10,, (_Mdouble_ __x));
-libm_hidden_proto(pow10)
 #endif
 
 #if defined __USE_MISC || defined __USE_XOPEN_EXTENDED || defined __USE_ISOC99
 __BEGIN_NAMESPACE_C99
 /* Return exp(X) - 1.  */
-__MATHCALL (expm1,, (_Mdouble_ __x));
-libm_hidden_proto(expm1)
+__MATHCALLI (expm1,, (_Mdouble_ __x));
 
 /* Return log(1 + X).  */
-__MATHCALL (log1p,, (_Mdouble_ __x));
-libm_hidden_proto(log1p)
+__MATHCALLI (log1p,, (_Mdouble_ __x));
 
 /* Return the base 2 signed integral exponent of X.  */
-__MATHCALL (logb,, (_Mdouble_ __x));
-libm_hidden_proto(logb)
+__MATHCALLI (logb,, (_Mdouble_ __x));
 __END_NAMESPACE_C99
 #endif
 
 #ifdef __USE_ISOC99
 __BEGIN_NAMESPACE_C99
 /* Compute base-2 exponential of X.  */
-__MATHCALL (exp2,, (_Mdouble_ __x));
-libm_hidden_proto(exp2)
+__MATHCALLI (exp2,, (_Mdouble_ __x));
 
 /* Compute base-2 logarithm of X.  */
 __MATHCALL (log2,, (_Mdouble_ __x));
-libm_hidden_proto(log2)
 __END_NAMESPACE_C99
 #endif
 
@@ -178,27 +151,23 @@
 
 _Mdouble_BEGIN_NAMESPACE
 /* Return X to the Y power.  */
-__MATHCALL (pow,, (_Mdouble_ __x, _Mdouble_ __y));
-libm_hidden_proto(pow)
+__MATHCALLI (pow,, (_Mdouble_ __x, _Mdouble_ __y));
 
 /* Return the square root of X.  */
-__MATHCALL (sqrt,, (_Mdouble_ __x));
-libm_hidden_proto(sqrt)
+__MATHCALLI (sqrt,, (_Mdouble_ __x));
 _Mdouble_END_NAMESPACE
 
 #if defined __USE_MISC || defined __USE_XOPEN || defined __USE_ISOC99
 __BEGIN_NAMESPACE_C99
 /* Return `sqrt(X*X + Y*Y)'.  */
-__MATHCALL (hypot,, (_Mdouble_ __x, _Mdouble_ __y));
-libm_hidden_proto(hypot)
+__MATHCALLI (hypot,, (_Mdouble_ __x, _Mdouble_ __y));
 __END_NAMESPACE_C99
 #endif
 
 #if defined __USE_MISC || defined __USE_XOPEN_EXTENDED || defined __USE_ISOC99
 __BEGIN_NAMESPACE_C99
 /* Return the cube root of X.  */
-__MATHCALL (cbrt,, (_Mdouble_ __x));
-libm_hidden_proto(cbrt)
+__MATHCALLI (cbrt,, (_Mdouble_ __x));
 __END_NAMESPACE_C99
 #endif
 
@@ -208,56 +177,46 @@
 _Mdouble_BEGIN_NAMESPACE
 /* Smallest integral value not less than X.  */
 __MATHCALLX (ceil,, (_Mdouble_ __x), (__const__));
-libm_hidden_proto(ceil)
 
 /* Absolute value of X.  */
 __MATHCALLX (fabs,, (_Mdouble_ __x), (__const__));
-libm_hidden_proto(fabs)
 
 /* Largest integer not greater than X.  */
 __MATHCALLX (floor,, (_Mdouble_ __x), (__const__));
-libm_hidden_proto(floor)
 
 /* Floating-point modulo remainder of X/Y.  */
-__MATHCALL (fmod,, (_Mdouble_ __x, _Mdouble_ __y));
-libm_hidden_proto(fmod)
+__MATHCALLI (fmod,, (_Mdouble_ __x, _Mdouble_ __y));
 
 
 /* Return 0 if VALUE is finite or NaN, +1 if it
    is +Infinity, -1 if it is -Infinity.  */
-__MATHDECL_1 (int,__isinf,, (_Mdouble_ __value)) __attribute__ ((__const__));
-libm_hidden_proto(__isinf)
+__MATHDECL_PRIV (int,isinf,, (_Mdouble_ __value), (__const__));
 
 /* Return nonzero if VALUE is finite and not NaN.  */
-__MATHDECL_1 (int,__finite,, (_Mdouble_ __value)) __attribute__ ((__const__));
-libm_hidden_proto(__finite)
+__MATHDECL_PRIV (int,finite,, (_Mdouble_ __value), (__const__));
 _Mdouble_END_NAMESPACE
 
 #ifdef __USE_MISC
+#if 0
 /* Return 0 if VALUE is finite or NaN, +1 if it
    is +Infinity, -1 if it is -Infinity.  */
-__MATHDECL_1 (int,isinf,, (_Mdouble_ __value)) __attribute__ ((__const__));
-libm_hidden_proto(isinf)
+__MATHDECL_PRIV (int,isinf,, (_Mdouble_ __value), (__const__));
 
 /* Return nonzero if VALUE is finite and not NaN.  */
-__MATHDECL_1 (int,finite,, (_Mdouble_ __value)) __attribute__ ((__const__));
-libm_hidden_proto(finite)
-
+__MATHDECL_PRIV (int,finite,, (_Mdouble_ __value), (__const__));
+#endif
 /* Return the remainder of X/Y.  */
 __MATHCALL (drem,, (_Mdouble_ __x, _Mdouble_ __y));
-libm_hidden_proto(drem)
 
 
 /* Return the fractional part of X after dividing out `ilogb (X)'.  */
 __MATHCALL (significand,, (_Mdouble_ __x));
-libm_hidden_proto(significand)
 #endif /* Use misc.  */
 
 #if defined __USE_MISC || defined __USE_ISOC99
 __BEGIN_NAMESPACE_C99
 /* Return X with its signed changed to Y's.  */
 __MATHCALLX (copysign,, (_Mdouble_ __x, _Mdouble_ __y), (__const__));
-libm_hidden_proto(copysign)
 __END_NAMESPACE_C99
 #endif
 
@@ -265,60 +224,46 @@
 __BEGIN_NAMESPACE_C99
 /* Return representation of NaN for double type.  */
 __MATHCALLX (nan,, (__const char *__tagb), (__const__));
-libm_hidden_proto(nan)
 __END_NAMESPACE_C99
 #endif
 
 
 /* Return nonzero if VALUE is not a number.  */
-__MATHDECL_1 (int,__isnan,, (_Mdouble_ __value)) __attribute__ ((__const__));
-libm_hidden_proto(__isnan)
+__MATHDECL_PRIV (int,__isnan,, (_Mdouble_ __value), (__const__));
 
 #if defined __USE_MISC || defined __USE_XOPEN
 /* Return nonzero if VALUE is not a number.  */
-__MATHDECL_1 (int,isnan,, (_Mdouble_ __value)) __attribute__ ((__const__));
-libm_hidden_proto(isnan)
+__MATHDECL_PRIV (int,isnan,, (_Mdouble_ __value), (__const__));
 
 /* Bessel functions.  */
 __MATHCALL (j0,, (_Mdouble_));
-libm_hidden_proto(j0)
 __MATHCALL (j1,, (_Mdouble_));
-libm_hidden_proto(j1)
 __MATHCALL (jn,, (int, _Mdouble_));
-libm_hidden_proto(jn)
 __MATHCALL (y0,, (_Mdouble_));
-libm_hidden_proto(y0)
 __MATHCALL (y1,, (_Mdouble_));
-libm_hidden_proto(y1)
 __MATHCALL (yn,, (int, _Mdouble_));
-libm_hidden_proto(yn)
 #endif
 
 
 #if defined __USE_MISC || defined __USE_XOPEN || defined __USE_ISOC99
 __BEGIN_NAMESPACE_C99
 /* Error and gamma functions.  */
-__MATHCALL (erf,, (_Mdouble_));
-libm_hidden_proto(erf)
-__MATHCALL (erfc,, (_Mdouble_));
-libm_hidden_proto(erfc)
-__MATHCALL (lgamma,, (_Mdouble_));
-libm_hidden_proto(lgamma)
+__MATHCALLI (erf,, (_Mdouble_));
+__MATHCALLI (erfc,, (_Mdouble_));
+__MATHCALLI (lgamma,, (_Mdouble_));
 __END_NAMESPACE_C99
 #endif
 
 #ifdef __USE_ISOC99
 __BEGIN_NAMESPACE_C99
 /* True gamma function.  */
-__MATHCALL (tgamma,, (_Mdouble_));
-libm_hidden_proto(tgamma)
+__MATHCALLI (tgamma,, (_Mdouble_));
 __END_NAMESPACE_C99
 #endif
 
 #if defined __USE_MISC || defined __USE_XOPEN
 /* Obsolete alias for `lgamma'.  */
 __MATHCALL (gamma,, (_Mdouble_));
-libm_hidden_proto(gamma)
 #endif
 
 #ifdef __USE_MISC
@@ -326,7 +271,6 @@
    `signgam'.  The reentrant version instead takes a pointer and stores
    the value through it.  */
 __MATHCALL (lgamma,_r, (_Mdouble_, int *__signgamp));
-libm_hidden_proto(lgamma_r)
 #endif
 
 
@@ -334,103 +278,80 @@
 __BEGIN_NAMESPACE_C99
 /* Return the integer nearest X in the direction of the
    prevailing rounding mode.  */
-__MATHCALL (rint,, (_Mdouble_ __x));
-libm_hidden_proto(rint)
+__MATHCALLI (rint,, (_Mdouble_ __x));
 
 /* Return X + epsilon if X < Y, X - epsilon if X > Y.  */
 __MATHCALLX (nextafter,, (_Mdouble_ __x, _Mdouble_ __y), (__const__));
-libm_hidden_proto(nextafter)
 # if defined __USE_ISOC99 && !defined __LDBL_COMPAT
 __MATHCALLX (nexttoward,, (_Mdouble_ __x, long double __y), (__const__));
-libm_hidden_proto(nexttoward)
 # endif
 
 /* Return the remainder of integer divison X / Y with infinite precision.  */
-__MATHCALL (remainder,, (_Mdouble_ __x, _Mdouble_ __y));
-libm_hidden_proto(remainder)
+__MATHCALLI (remainder,, (_Mdouble_ __x, _Mdouble_ __y));
 
 # if defined __USE_MISC || defined __USE_ISOC99
 /* Return X times (2 to the Nth power).  */
-__MATHCALL (scalbn,, (_Mdouble_ __x, int __n));
-libm_hidden_proto(scalbn)
+__MATHCALLI (scalbn,, (_Mdouble_ __x, int __n));
 # endif
 
 /* Return the binary exponent of X, which must be nonzero.  */
-__MATHDECL (int,ilogb,, (_Mdouble_ __x));
-libm_hidden_proto(ilogb)
+__MATHDECLI (int,ilogb,, (_Mdouble_ __x));
 #endif
 
 #ifdef __USE_ISOC99
 /* Return X times (2 to the Nth power).  */
-__MATHCALL (scalbln,, (_Mdouble_ __x, long int __n));
-libm_hidden_proto(scalbln)
+__MATHCALLI (scalbln,, (_Mdouble_ __x, long int __n));
 
 /* Round X to integral value in floating-point format using current
    rounding direction, but do not raise inexact exception.  */
-__MATHCALL (nearbyint,, (_Mdouble_ __x));
-libm_hidden_proto(nearbyint)
+__MATHCALLI (nearbyint,, (_Mdouble_ __x));
 
 /* Round X to nearest integral value, rounding halfway cases away from
    zero.  */
 __MATHCALLX (round,, (_Mdouble_ __x), (__const__));
-libm_hidden_proto(round)
 
 /* Round X to the integral value in floating-point format nearest but
    not larger in magnitude.  */
 __MATHCALLX (trunc,, (_Mdouble_ __x), (__const__));
-libm_hidden_proto(trunc)
 
 /* Compute remainder of X and Y and put in *QUO a value with sign of x/y
    and magnitude congruent `mod 2^n' to the magnitude of the integral
    quotient x/y, with n >= 3.  */
-__MATHCALL (remquo,, (_Mdouble_ __x, _Mdouble_ __y, int *__quo));
-libm_hidden_proto(remquo)
+__MATHCALLI (remquo,, (_Mdouble_ __x, _Mdouble_ __y, int *__quo));
 
 
 /* Conversion functions.  */
 
 /* Round X to nearest integral value according to current rounding
    direction.  */
-__MATHDECL (long int,lrint,, (_Mdouble_ __x));
-libm_hidden_proto(lrint)
-__MATHDECL (long long int,llrint,, (_Mdouble_ __x));
-libm_hidden_proto(llrint)
+__MATHDECLI (long int,lrint,, (_Mdouble_ __x));
+__MATHDECLI (long long int,llrint,, (_Mdouble_ __x));
 
 /* Round X to nearest integral value, rounding halfway cases away from
    zero.  */
-__MATHDECL (long int,lround,, (_Mdouble_ __x));
-libm_hidden_proto(lround)
-__MATHDECL (long long int,llround,, (_Mdouble_ __x));
-libm_hidden_proto(llround)
+__MATHDECLI (long int,lround,, (_Mdouble_ __x));
+__MATHDECLI (long long int,llround,, (_Mdouble_ __x));
 
 
 /* Return positive difference between X and Y.  */
-__MATHCALL (fdim,, (_Mdouble_ __x, _Mdouble_ __y));
-libm_hidden_proto(fdim)
+__MATHCALLI (fdim,, (_Mdouble_ __x, _Mdouble_ __y));
 
 /* Return maximum numeric value from X and Y.  */
-__MATHCALL (fmax,, (_Mdouble_ __x, _Mdouble_ __y));
-libm_hidden_proto(fmax)
+__MATHCALLI (fmax,, (_Mdouble_ __x, _Mdouble_ __y));
 
 /* Return minimum numeric value from X and Y.  */
-__MATHCALL (fmin,, (_Mdouble_ __x, _Mdouble_ __y));
-libm_hidden_proto(fmin)
+__MATHCALLI (fmin,, (_Mdouble_ __x, _Mdouble_ __y));
 
 
 /* Classify given number.  */
-__MATHDECL_1 (int, __fpclassify,, (_Mdouble_ __value))
-     __attribute__ ((__const__));
-libm_hidden_proto(__fpclassify)
+__MATHDECL_PRIV (int, fpclassify,, (_Mdouble_ __value), (__const__));
 
 /* Test for negative number.  */
-__MATHDECL_1 (int, __signbit,, (_Mdouble_ __value))
-     __attribute__ ((__const__));
-libm_hidden_proto(__signbit)
+__MATHDECL_PRIV (int, signbit,, (_Mdouble_ __value), (__const__));
 
 
 /* Multiply-add function computed as a ternary operation.  */
-__MATHCALL (fma,, (_Mdouble_ __x, _Mdouble_ __y, _Mdouble_ __z));
-libm_hidden_proto(fma)
+__MATHCALLI (fma,, (_Mdouble_ __x, _Mdouble_ __y, _Mdouble_ __z));
 #endif /* Use ISO C99.  */
 
 #if defined __USE_MISC || defined __USE_XOPEN_EXTENDED || defined __USE_ISOC99
@@ -440,5 +361,4 @@
 #if defined __USE_MISC || defined __USE_XOPEN_EXTENDED
 /* Return X times (2 to the Nth power).  */
 __MATHCALL (scalb,, (_Mdouble_ __x, _Mdouble_ __n));
-libm_hidden_proto(scalb)
 #endif
