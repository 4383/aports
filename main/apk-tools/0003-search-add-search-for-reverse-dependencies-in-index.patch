From d9bf4aabff801164b4c54e51b38c5f6eab2da114 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timo=20Ter=C3=A4s?= <timo.teras@iki.fi>
Date: Wed, 19 May 2010 16:48:40 +0300
Subject: [PATCH 3/5] search: add search for reverse dependencies in index

So it'll be easier to rebuild affected packages. Fixes #349.
---
 src/search.c |  148 +++++++++++++++++++++++++++++++++++----------------------
 1 files changed, 91 insertions(+), 57 deletions(-)

diff --git a/src/search.c b/src/search.c
index 91c2913..e5e5d55 100644
--- a/src/search.c
+++ b/src/search.c
@@ -18,18 +18,14 @@
 #include "apk_state.h"
 
 struct search_ctx {
-	int (*action)(struct apk_database *db, int argc, char **argv);
+	int (*match)(struct apk_package *pkg, const char *str);
+	int (*print)(struct apk_package *pkg);
+	int argc;
+	char **argv;
 };
 
-struct search_query_ctx {
-	struct apk_database *db;
-	const char *query;
-};
-
-static int search_list_print(apk_hash_item item, void *ctx)
+static int print_match(struct apk_package *pkg)
 {
-	struct apk_package *pkg = (struct apk_package *) item;
-
 	printf("%s", pkg->name->name);
 	if (apk_verbosity > 0)
 		printf("-%s", pkg->version);
@@ -41,61 +37,50 @@ static int search_list_print(apk_hash_item item, void *ctx)
 	return 0;
 }
 
-static int search_query_print(apk_hash_item item, void *ctx)
+static int print_rdepends(struct apk_package *pkg)
 {
-	struct search_query_ctx *ictx = (struct search_query_ctx *) ctx;
-	struct apk_package *pkg = (struct apk_package *) item;
+	struct apk_name *name, *name0;
+	struct apk_package *pkg0;
+	struct apk_dependency *dep;
+	int i, j, k;
 
-	if (fnmatch(ictx->query, pkg->name->name, 0) != 0)
+	name = pkg->name;
+	if (name->rdepends == NULL)
 		return 0;
-	search_list_print(item, ictx->db);
-
-	return 0;
-}
-
-static int search_list(struct apk_database *db, int argc, char **argv)
-{
-	int i;
-	struct search_query_ctx ctx;
-
-	ctx.db = db;
 
-	if (argc == 0)
-		apk_hash_foreach(&db->available.packages, search_list_print, db);
-	else
-		for (i=0; i<argc; i++) {
-			ctx.query = argv[i];
-			apk_hash_foreach(&db->available.packages, search_query_print, &ctx);
+	printf("%s-%s:", pkg->name->name, pkg->version);
+	for (i = 0; i < name->rdepends->num; i++) {
+		name0 = name->rdepends->item[i];
+		if (name0->pkgs == NULL)
+			continue;
+		for (j = 0; j < name0->pkgs->num; j++) {
+			pkg0 = name0->pkgs->item[j];
+			if (pkg0->depends == NULL)
+				continue;
+			for (k = 0; k < pkg0->depends->num; k++) {
+				dep = &pkg0->depends->item[k];
+				if (name == dep->name &&
+				    (apk_version_compare(pkg->version, dep->version)
+				      & dep->result_mask)) {
+					printf(" %s-%s", pkg0->name->name, pkg0->version);
+				}
+			}
 		}
+	}
+	printf("\n");
 
 	return 0;
 }
 
-static int search_query_desc_print(apk_hash_item item, void *ctx)
+static int search_pkgname(struct apk_package *pkg, const char *str)
 {
-	struct search_query_ctx *ictx = (struct search_query_ctx *) ctx;
-	struct apk_package *pkg = (struct apk_package *) item;
-
-	if( strstr(pkg->description, ictx->query) == NULL )
-		return 0;
-	search_list_print(item, ictx->db);
-
-	return 0;
+	return fnmatch(str, pkg->name->name, 0) == 0;
 }
 
-static int search_desc(struct apk_database *db, int argc, char **argv)
+static int search_desc(struct apk_package *pkg, const char *str)
 {
-	int i;
-	struct search_query_ctx ctx;
-
-	ctx.db = db;
-
-	for (i=0; i<argc; i++) {
-		ctx.query = argv[i];
-		apk_hash_foreach(&db->available.packages, search_query_desc_print, &ctx);
-	}
-
-	return 0;
+	return  strstr(pkg->name->name, str) != NULL ||
+		strstr(pkg->description, str) != NULL;
 }
 
 static int search_parse(void *ctx, struct apk_db_options *dbopts,
@@ -105,7 +90,10 @@ static int search_parse(void *ctx, struct apk_db_options *dbopts,
 
 	switch (optch) {
 	case 'd':
-		ictx->action = search_desc;
+		ictx->match = search_desc;
+		break;
+	case 'r':
+		ictx->print = print_rdepends;
 		break;
 	default:
 		return -1;
@@ -113,23 +101,69 @@ static int search_parse(void *ctx, struct apk_db_options *dbopts,
 	return 0;
 }
 
+static int match_packages(apk_hash_item item, void *ctx)
+{
+	struct search_ctx *ictx = (struct search_ctx *) ctx;
+	struct apk_package *pkg = (struct apk_package *) item;
+	int i;
+
+	for (i = 0; i < ictx->argc; i++)
+		if (ictx->match(pkg, ictx->argv[i]))
+			break;
+	if (ictx->argc == 0 || i < ictx->argc)
+		ictx->print(pkg);
+
+	return 0;
+}
+
 static int search_main(void *ctx, struct apk_database *db, int argc, char **argv)
 {
 	struct search_ctx *ictx = (struct search_ctx *) ctx;
+	struct apk_name *name;
+	int rc = 0, i, j, slow_search;
+
+	slow_search = ictx->match != NULL || argc == 0;
+	if (!slow_search) {
+		for (i = 0; i < argc; i++)
+			if (strcspn(argv[i], "*?[") != strlen(argv[i])) {
+				slow_search = 1;
+				break;
+			}
+	}
+
+	if (ictx->match == NULL)
+		ictx->match = search_pkgname;
+	if (ictx->print == NULL)
+		ictx->print = print_match;
+	else if (argc == 0)
+		return -1;
 
-	if (ictx->action != NULL)
-		return ictx->action(db, argc, argv);
+	if (slow_search) {
+		ictx->argc = argc;
+		ictx->argv = argv;
+		rc = apk_hash_foreach(&db->available.packages,
+				      match_packages, ictx);
+	} else {
+		for (i = 0; i < argc; i++) {
+			name = apk_db_query_name(db, APK_BLOB_STR(argv[i]));
+			if (name == NULL || name->pkgs == NULL)
+				continue;
+			for (j = 0; j < name->pkgs->num; j++)
+				ictx->print(name->pkgs->item[j]);
+		}
+	}
 
-	return search_list(db, argc, argv);
+	return rc;
 }
 
 static struct apk_option search_options[] = {
-	{ 'd', "description", "Search also package descriptions" },
+	{ 'd', "description",	"Search also package descriptions" },
+	{ 'r', "rdepends",	"Print reverse dependencies of package" },
 };
 
 static struct apk_applet apk_search = {
 	.name = "search",
-	.help = "Search package names (and descriptions) by wildcard PATTERN.",
+	.help = "Search package by PATTERNs or by indexed dependencies.",
 	.arguments = "PATTERN",
 	.open_flags = APK_OPENF_READ | APK_OPENF_NO_STATE,
 	.context_size = sizeof(struct search_ctx),
-- 
1.7.1

