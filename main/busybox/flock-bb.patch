From: Timo Teras <timo.teras@iki.fi>
To: busybox@busybox.net
Subject: [PATCH] flock: new applet
Date: Tue, 16 Mar 2010 14:14:22 +0200
Message-Id: <1268741663-8790-1-git-send-email-timo.teras@iki.fi>
X-Mailer: git-send-email 1.6.3.3

An utility to manage file locks from scripts.

Signed-off-by: Timo Teras <timo.teras@iki.fi>
---
 include/applets.h    |    1 +
 include/usage.h      |   11 ++++++
 util-linux/Config.in |    6 +++
 util-linux/Kbuild    |    1 +
 util-linux/flock.c   |   93 ++++++++++++++++++++++++++++++++++++++++++++++++++
 5 files changed, 112 insertions(+), 0 deletions(-)
 create mode 100644 util-linux/flock.c

diff --git a/include/applets.h b/include/applets.h
index 2d784bd..83c1792 100644
--- a/include/applets.h
+++ b/include/applets.h
@@ -161,6 +161,7 @@ IF_FLASH_ERASEALL(APPLET(flash_eraseall, _BB_DIR_USR_SBIN, _BB_SUID_DROP))
 IF_FLASH_LOCK(APPLET_ODDNAME(flash_lock, flash_lock_unlock, _BB_DIR_USR_SBIN, _BB_SUID_DROP, flash_lock))
 IF_FLASH_UNLOCK(APPLET_ODDNAME(flash_unlock, flash_lock_unlock, _BB_DIR_USR_SBIN, _BB_SUID_DROP, flash_unlock))
 IF_FLASHCP(APPLET(flashcp, _BB_DIR_USR_SBIN, _BB_SUID_DROP))
+IF_FLOCK(APPLET(flock, _BB_DIR_USR_BIN, _BB_SUID_DROP))
 IF_FOLD(APPLET(fold, _BB_DIR_USR_BIN, _BB_SUID_DROP))
 IF_FREE(APPLET(free, _BB_DIR_USR_BIN, _BB_SUID_DROP))
 IF_FREERAMDISK(APPLET(freeramdisk, _BB_DIR_SBIN, _BB_SUID_DROP))
diff --git a/include/usage.h b/include/usage.h
index f4259a1..cbf6bef 100644
--- a/include/usage.h
+++ b/include/usage.h
@@ -1312,6 +1312,17 @@
      "\nOptions:" \
      "\n	-v	Verbose" \
 
+#define flock_trivial_usage \
+       "[-sxun] [fd# | FILE] [-c] command"
+#define flock_full_usage "\n\n" \
+       "Manage file locks from scripts\n" \
+     "\nOptions:" \
+     "\n	-s	Get a shared lock" \
+     "\n	-x	Get an exclusive lock" \
+     "\n	-u	Remove a lock (from fd#)" \
+     "\n	-n	Fail rather than wait" \
+     "\n	-c	Command to run" \
+
 #define fold_trivial_usage \
        "[-bs] [-w WIDTH] [FILE]..."
 #define fold_full_usage "\n\n" \
diff --git a/util-linux/Config.in b/util-linux/Config.in
index f04511b..d0d8df3 100644
--- a/util-linux/Config.in
+++ b/util-linux/Config.in
@@ -191,6 +191,12 @@ config FINDFS
 	  WARNING:
 	  With all submodules selected, it will add ~8k to busybox.
 
+config FLOCK
+	bool "flock"
+	default y
+	help
+	  Manage locks from shell scripts
+
 config FREERAMDISK
 	bool "freeramdisk"
 	default n
diff --git a/util-linux/Kbuild b/util-linux/Kbuild
index 72a2ef1..99e3efe 100644
--- a/util-linux/Kbuild
+++ b/util-linux/Kbuild
@@ -13,6 +13,7 @@ lib-$(CONFIG_FDFLUSH)           += freeramdisk.o
 lib-$(CONFIG_FDFORMAT)          += fdformat.o
 lib-$(CONFIG_FDISK)             += fdisk.o
 lib-$(CONFIG_FINDFS)            += findfs.o
+lib-$(CONFIG_FLOCK)             += flock.o
 lib-$(CONFIG_FREERAMDISK)       += freeramdisk.o
 lib-$(CONFIG_FSCK_MINIX)        += fsck_minix.o
 lib-$(CONFIG_GETOPT)            += getopt.o
diff --git a/util-linux/flock.c b/util-linux/flock.c
new file mode 100644
index 0000000..e9a22d5
--- /dev/null
+++ b/util-linux/flock.c
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2010 Timo Teras <timo.teras@iki.fi>
+ *
+ * This is free software, licensed under the GNU General Public License v2.
+ */
+#include <sys/types.h>
+#include <sys/file.h>
+#include <sys/stat.h>
+#include <signal.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdio.h>
+#include "busybox.h"
+
+int flock_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int flock_main(int argc, char **argv)
+{
+	char *command = NULL;
+	int mode, opt, fd, status = 0;
+	enum {
+		OPT_s = (1 << 0),
+		OPT_x = (1 << 1),
+		OPT_u = (1 << 2),
+		OPT_n = (1 << 3),
+		OPT_c = (1 << 4),
+	};
+
+#if ENABLE_LONG_OPTS
+        static const char getopt_longopts[] ALIGN1 =
+		"shared\0"	No_argument       "s"
+		"exclusive\0"	No_argument       "x"
+		"unblock\0"	No_argument       "u"
+		"nonblock\0"	No_argument	  "n"
+		"command\0"	Required_argument "c"
+		;
+	applet_long_options = getopt_longopts;
+#endif
+
+	opt = getopt32(argv, "sxunc:", &command);
+	argv += optind;
+	argc -= optind;
+
+	if (argv[0] == NULL)
+	        bb_show_usage();
+
+	if (command != NULL || argc > 1) {
+		fd = open(argv[0], O_RDONLY|O_NOCTTY|O_CREAT, 0666);
+		if (fd < 0 && errno == EISDIR)
+		        fd = open(argv[0], O_RDONLY|O_NOCTTY);
+	} else {
+		fd = atoi(argv[0]);
+	}
+	if (fd < 0)
+	        bb_perror_msg_and_die("cannot open: '%s'", argv[0]);
+
+	argv++;
+	if (command == NULL)
+	        command = argv[0];
+
+	if (opt & OPT_u)
+		mode = LOCK_UN;
+	else if (opt & OPT_s)
+		mode = LOCK_SH;
+	else
+		mode = LOCK_EX;
+
+	if (opt & OPT_n)
+		mode |= LOCK_NB;
+
+	if (flock(fd, mode) && errno == EWOULDBLOCK)
+		return 1;
+
+	if (command != NULL) {
+	        pid_t pid;
+
+	        pid = fork();
+	        if (pid < 0)
+                        bb_perror_msg_and_die("fork failed");
+                if (pid == 0) {
+                        execvp(command, argv);
+                        exit(1);
+                }
+                waitpid(pid, &status, 0);
+                if (WIFEXITED(status))
+                        status = WEXITSTATUS(status);
+                else if (WIFSIGNALED(status))
+                        status = WTERMSIG(status) + 128;
+                else
+                        status = 1;
+        }
+
+	return status;
+}
-- 
1.6.3.3
