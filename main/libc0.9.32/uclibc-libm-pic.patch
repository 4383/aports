GCC can emit prologue/epilogue code for the functions in various
different cases:
 - frame pointers
 - PIC build (to load ebx for indirect calls/jumps)
 - forced stack smashing protection

If we used jump in such cases, we'd corrupt the call stack and
crash.

Signed-off-by: Timo Ter√§s <timo.teras at iki.fi>
---
 libm/ldouble_wrappers.c |   12 +++++++-----
 1 files changed, 7 insertions(+), 5 deletions(-)

diff --git a/libm/ldouble_wrappers.c b/libm/ldouble_wrappers.c
index 7d5af90..5b424dc 100644
--- a/libm/ldouble_wrappers.c
+++ b/libm/ldouble_wrappers.c
@@ -60,7 +60,9 @@ long long func##l(long double x) \
  * The return value is returned in st(0) per ABI in both cases (returning
  * a long double or returning a double). So we can simply jump to func.
  * Using __GI_func in jump to make optimized intra-library jump.
- * gcc will still generate a useless "ret" after asm. Oh well...
+ *
+ * We do need to use call (instead of tail jump) as gcc can create
+ * stack frame, and push/modify/pop ebx during PIC build.
  */
 # define WRAPPER1(func) \
 long double func##l(long double x) \
@@ -69,7 +71,7 @@ long double func##l(long double x) \
 	__asm ( \
 	"	fldt	%1\n" \
 	"	fstpl	%1\n" \
-	"	jmp	" __stringify(__GI_##func) "\n" \
+	"	call	" __stringify(__GI_##func) "\n" \
 	: "=t" (st_top) \
 	: "m" (x) \
 	); \
@@ -82,7 +84,7 @@ int func##l(long double x) \
 	__asm ( \
 	"	fldt	%1\n" \
 	"	fstpl	%1\n" \
-	"	jmp	" __stringify(__GI_##func) "\n" \
+	"	call	" __stringify(__GI_##func) "\n" \
 	: "=a" (ret) \
 	: "m" (x) \
 	); \
@@ -95,7 +97,7 @@ long func##l(long double x) \
 	__asm ( \
 	"	fldt	%1\n" \
 	"	fstpl	%1\n" \
-	"	jmp	" __stringify(__GI_##func) "\n" \
+	"	call	" __stringify(__GI_##func) "\n" \
 	: "=a" (ret) \
 	: "m" (x) \
 	); \
@@ -108,7 +110,7 @@ long long func##l(long double x) \
 	__asm ( \
 	"	fldt	%1\n" \
 	"	fstpl	%1\n" \
-	"	jmp	" __stringify(__GI_##func) "\n" \
+	"	call	" __stringify(__GI_##func) "\n" \
 	: "=A" (ret) \
 	: "m" (x) \
 	); \
-- 
1.7.0.4
