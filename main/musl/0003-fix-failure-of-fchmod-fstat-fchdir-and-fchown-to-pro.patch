From 65ea604c74f3fecbc61a266a22fdf527764995b6 Mon Sep 17 00:00:00 2001
From: Rich Felker <dalias@aerifal.cx>
Date: Thu, 19 Dec 2013 14:24:55 -0500
Subject: [PATCH 1/1] fix failure of fchmod, fstat, fchdir, and fchown to
 produce EBADF

the workaround/fallback code for supporting O_PATH file descriptors
when the kernel lacks support for performing these operations on them
caused EBADF to get replaced by ENOENT (due to missing entry in
/proc/self/fd). this is unlikely to affect real-world code (calls that
might yield EBADF are generally unsafe, especially in library code)
but it was breaking some test cases.

the fix I've applied is something of a tradeoff: it adds one syscall
to these operations on kernels where the workaround is needed. the
alternative would be to catch ENOENT from the /proc lookup and
translate it to EBADF, but I want to avoid doing that in the interest
of not touching/depending on /proc at all in these functions as long
as the kernel correctly supports the operations. this is following the
general principle of isolating hacks to code paths that are taken on
broken systems, and keeping the code for correct systems completely
hack-free.
---
 src/stat/fchmod.c   | 4 +++-
 src/stat/fstat.c    | 4 +++-
 src/unistd/fchdir.c | 4 +++-
 src/unistd/fchown.c | 4 +++-
 4 files changed, 12 insertions(+), 4 deletions(-)

diff --git a/src/stat/fchmod.c b/src/stat/fchmod.c
index 1b943d4..6d28141 100644
--- a/src/stat/fchmod.c
+++ b/src/stat/fchmod.c
@@ -1,5 +1,6 @@
 #include <sys/stat.h>
 #include <errno.h>
+#include <fcntl.h>
 #include "syscall.h"
 
 void __procfdname(char *, unsigned);
@@ -7,7 +8,8 @@ void __procfdname(char *, unsigned);
 int fchmod(int fd, mode_t mode)
 {
 	int ret = __syscall(SYS_fchmod, fd, mode);
-	if (ret != -EBADF || fd < 0) return __syscall_ret(ret);
+	if (ret != -EBADF || __syscall(SYS_fcntl, fd, F_GETFD) < 0)
+		return __syscall_ret(ret);
 
 	char buf[15+3*sizeof(int)];
 	__procfdname(buf, fd);
diff --git a/src/stat/fstat.c b/src/stat/fstat.c
index 29b4243..b561176 100644
--- a/src/stat/fstat.c
+++ b/src/stat/fstat.c
@@ -1,5 +1,6 @@
 #include <sys/stat.h>
 #include <errno.h>
+#include <fcntl.h>
 #include "syscall.h"
 #include "libc.h"
 
@@ -8,7 +9,8 @@ void __procfdname(char *, unsigned);
 int fstat(int fd, struct stat *st)
 {
 	int ret = __syscall(SYS_fstat, fd, st);
-	if (ret != -EBADF || fd < 0) return __syscall_ret(ret);
+	if (ret != -EBADF || __syscall(SYS_fcntl, fd, F_GETFD) < 0)
+		return __syscall_ret(ret);
 
 	char buf[15+3*sizeof(int)];
 	__procfdname(buf, fd);
diff --git a/src/unistd/fchdir.c b/src/unistd/fchdir.c
index 9fbc815..72c3915 100644
--- a/src/unistd/fchdir.c
+++ b/src/unistd/fchdir.c
@@ -1,5 +1,6 @@
 #include <unistd.h>
 #include <errno.h>
+#include <fcntl.h>
 #include "syscall.h"
 
 void __procfdname(char *, unsigned);
@@ -7,7 +8,8 @@ void __procfdname(char *, unsigned);
 int fchdir(int fd)
 {
 	int ret = __syscall(SYS_fchdir, fd);
-	if (ret != -EBADF || fd < 0) return __syscall_ret(ret);
+	if (ret != -EBADF || __syscall(SYS_fcntl, fd, F_GETFD) < 0)
+		return __syscall_ret(ret);
 
 	char buf[15+3*sizeof(int)];
 	__procfdname(buf, fd);
diff --git a/src/unistd/fchown.c b/src/unistd/fchown.c
index e1c3198..36633b0 100644
--- a/src/unistd/fchown.c
+++ b/src/unistd/fchown.c
@@ -1,5 +1,6 @@
 #include <unistd.h>
 #include <errno.h>
+#include <fcntl.h>
 #include "syscall.h"
 
 void __procfdname(char *, unsigned);
@@ -7,7 +8,8 @@ void __procfdname(char *, unsigned);
 int fchown(int fd, uid_t uid, gid_t gid)
 {
 	int ret = __syscall(SYS_fchown, fd, uid, gid);
-	if (ret != -EBADF || fd < 0) return __syscall_ret(ret);
+	if (ret != -EBADF || __syscall(SYS_fcntl, fd, F_GETFD) < 0)
+		return __syscall_ret(ret);
 
 	char buf[15+3*sizeof(int)];
 	__procfdname(buf, fd);
-- 
1.8.5.1

