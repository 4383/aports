# HG changeset patch
# User John Lindgren <john.lindgren@tds.net>
# Date 1292029591 18000
# Node ID 21ec3fe20e6fdffb5758aa847310944021dda67d
# Parent  eb47af70d029335ac12b4eb7e02d5664069439fa
alsa: Make delay time for poll() workaround depend on period size.
alsa: Fix thread logic.

diff -r eb47af70d029 -r 21ec3fe20e6f src/alsa/alsa.c
--- a/src/alsa/alsa.c	Fri Dec 10 11:47:49 2010 -0500
+++ b/src/alsa/alsa.c	Fri Dec 10 20:06:31 2010 -0500
@@ -79,6 +79,7 @@
 
 static void * alsa_buffer;
 static int alsa_buffer_length, alsa_buffer_data_start, alsa_buffer_data_length;
+static int alsa_period; /* milliseconds */
 
 static int64_t alsa_written; /* frames */
 static char alsa_prebuffer, alsa_paused;
@@ -195,6 +196,9 @@
             continue;
         }
 
+        if (! snd_pcm_bytes_to_frames (alsa_handle, alsa_buffer_data_length))
+            continue;
+
     WAIT:
         pthread_mutex_unlock (& alsa_mutex);
 
@@ -215,7 +219,8 @@
 
         if (workaround && slept)
         {
-            const struct timespec delay = {.tv_sec = 00, .tv_nsec = 100000000};
+            const struct timespec delay = {.tv_sec = 0, .tv_nsec = 600000 *
+             alsa_period};
             nanosleep (& delay, NULL);
         }
         else
@@ -380,14 +385,14 @@
     direction = 0;
     CHECK_NOISY (snd_pcm_hw_params_set_period_time_near, alsa_handle, params,
      & useconds, & direction);
-    int period = useconds / 1000;
+    alsa_period = useconds / 1000;
 
     CHECK_NOISY (snd_pcm_hw_params, alsa_handle, params);
 
     int soft_buffer = MAX (aud_cfg->output_buffer_size / 2,
      aud_cfg->output_buffer_size - hard_buffer);
     AUDDBG ("Buffer: hardware %d ms, software %d ms, period %d ms.\n",
-     hard_buffer, soft_buffer, period);
+     hard_buffer, soft_buffer, alsa_period);
 
     alsa_buffer_length = snd_pcm_frames_to_bytes (alsa_handle, (int64_t)
      soft_buffer * rate / 1000);
@@ -468,6 +473,9 @@
     alsa_buffer_data_length += length;
     alsa_written += snd_pcm_bytes_to_frames (alsa_handle, length);
 
+    if (! alsa_paused)
+        pthread_cond_broadcast (& alsa_cond);
+
     pthread_mutex_unlock (& alsa_mutex);
 }
 
