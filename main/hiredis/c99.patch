From c8fdb7a35ca062b4d9bbde0a883cf39023a49267 Mon Sep 17 00:00:00 2001
From: Natanael Copa <ncopa@alpinelinux.org>
Date: Wed, 29 Apr 2015 09:47:48 +0000
Subject: [PATCH] avoid name clash with system specific predefined macro 'unix'

It is common to find 'unix' defined on Unix systems before c99. While we
can force that hiredis itself is compiled with c99, we cannot really
enforce that all projects using the hiredis headers are compiled with
c99.

So avoid the use of 'unix' in the public headers.

The problem was introduced with commit d9e0b0f6 (Implement a reconnect
method for the client context, 2015-04-16)

See also:
http://stackoverflow.com/questions/3770322/is-unix-restricted-keyword-in-c

This fixes #321
---
 hiredis.c | 24 ++++++++++++------------
 hiredis.h |  4 ++--
 net.c     | 30 +++++++++++++++---------------
 3 files changed, 29 insertions(+), 29 deletions(-)

diff --git a/hiredis.c b/hiredis.c
index c70ea39..b4eb833 100644
--- a/hiredis.c
+++ b/hiredis.c
@@ -600,9 +600,9 @@ static redisContext *redisContextInit(void) {
     c->errstr[0] = '\0';
     c->obuf = sdsempty();
     c->reader = redisReaderCreate();
-    c->tcp.host = NULL;
-    c->tcp.source_addr = NULL;
-    c->unix.path = NULL;
+    c->c_tcp.host = NULL;
+    c->c_tcp.source_addr = NULL;
+    c->c_unix.path = NULL;
     c->timeout = NULL;
 
     if (c->obuf == NULL || c->reader == NULL) {
@@ -622,12 +622,12 @@ void redisFree(redisContext *c) {
         sdsfree(c->obuf);
     if (c->reader != NULL)
         redisReaderFree(c->reader);
-    if (c->tcp.host)
-        free(c->tcp.host);
-    if (c->tcp.source_addr)
-        free(c->tcp.source_addr);
-    if (c->unix.path)
-        free(c->unix.path);
+    if (c->c_tcp.host)
+        free(c->c_tcp.host);
+    if (c->c_tcp.source_addr)
+        free(c->c_tcp.source_addr);
+    if (c->c_unix.path)
+        free(c->c_unix.path);
     if (c->timeout)
         free(c->timeout);
     free(c);
@@ -655,10 +655,10 @@ int redisReconnect(redisContext *c) {
     c->reader = redisReaderCreate();
 
     if (c->connection_type == REDIS_CONN_TCP) {
-        return redisContextConnectBindTcp(c, c->tcp.host, c->tcp.port,
-                c->timeout, c->tcp.source_addr);
+        return redisContextConnectBindTcp(c, c->c_tcp.host, c->c_tcp.port,
+                c->timeout, c->c_tcp.source_addr);
     } else if (c->connection_type == REDIS_CONN_UNIX) {
-        return redisContextConnectUnix(c, c->unix.path, c->timeout);
+        return redisContextConnectUnix(c, c->c_unix.path, c->timeout);
     } else {
         /* Something bad happened here and shouldn't have. There isn't
            enough information in the context to reconnect. */
diff --git a/hiredis.h b/hiredis.h
index 092ded2..17e8683 100644
--- a/hiredis.h
+++ b/hiredis.h
@@ -151,11 +151,11 @@ typedef struct redisContext {
         char *host;
         char *source_addr;
         int port;
-    } tcp;
+    } c_tcp;
 
     struct {
         char *path;
-    } unix;
+    } c_unix;
 
 } redisContext;
 
diff --git a/net.c b/net.c
index fa0dabe..cd1a246 100644
--- a/net.c
+++ b/net.c
@@ -267,7 +267,7 @@ static int _redisContextConnectTcp(redisContext *c, const char *addr, int port,
     int reuses = 0;
 
     c->connection_type = REDIS_CONN_TCP;
-    c->tcp.port = port;
+    c->c_tcp.port = port;
 
     /* We need to take possession of the passed parameters
      * to make them reusable for a reconnect.
@@ -276,11 +276,11 @@ static int _redisContextConnectTcp(redisContext *c, const char *addr, int port,
      *
      * This is a bit ugly, but atleast it works and doesn't leak memory.
      **/
-    if (c->tcp.host != addr) {
-        if (c->tcp.host)
-            free(c->tcp.host);
+    if (c->c_tcp.host != addr) {
+        if (c->c_tcp.host)
+            free(c->c_tcp.host);
 
-        c->tcp.host = strdup(addr);
+        c->c_tcp.host = strdup(addr);
     }
 
     if (timeout) {
@@ -297,11 +297,11 @@ static int _redisContextConnectTcp(redisContext *c, const char *addr, int port,
     }
 
     if (source_addr == NULL) {
-        free(c->tcp.source_addr);
-        c->tcp.source_addr = NULL;
-    } else if (c->tcp.source_addr != source_addr) {
-        free(c->tcp.source_addr);
-        c->tcp.source_addr = strdup(source_addr);
+        free(c->c_tcp.source_addr);
+        c->c_tcp.source_addr = NULL;
+    } else if (c->c_tcp.source_addr != source_addr) {
+        free(c->c_tcp.source_addr);
+        c->c_tcp.source_addr = strdup(source_addr);
     }
 
     snprintf(_port, 6, "%d", port);
@@ -314,7 +314,7 @@ static int _redisContextConnectTcp(redisContext *c, const char *addr, int port,
      * as this would add latency to every connect. Otherwise a more sensible
      * route could be: Use IPv6 if both addresses are available and there is IPv6
      * connectivity. */
-    if ((rv = getaddrinfo(c->tcp.host,_port,&hints,&servinfo)) != 0) {
+    if ((rv = getaddrinfo(c->c_tcp.host,_port,&hints,&servinfo)) != 0) {
          hints.ai_family = AF_INET6;
          if ((rv = getaddrinfo(addr,_port,&hints,&servinfo)) != 0) {
             __redisSetError(c,REDIS_ERR_OTHER,gai_strerror(rv));
@@ -329,10 +329,10 @@ static int _redisContextConnectTcp(redisContext *c, const char *addr, int port,
         c->fd = s;
         if (redisSetBlocking(c,0) != REDIS_OK)
             goto error;
-        if (c->tcp.source_addr) {
+        if (c->c_tcp.source_addr) {
             int bound = 0;
             /* Using getaddrinfo saves us from self-determining IPv4 vs IPv6 */
-            if ((rv = getaddrinfo(c->tcp.source_addr, NULL, &hints, &bservinfo)) != 0) {
+            if ((rv = getaddrinfo(c->c_tcp.source_addr, NULL, &hints, &bservinfo)) != 0) {
                 char buf[128];
                 snprintf(buf,sizeof(buf),"Can't get addr: %s",gai_strerror(rv));
                 __redisSetError(c,REDIS_ERR_OTHER,buf);
@@ -422,8 +422,8 @@ int redisContextConnectUnix(redisContext *c, const char *path, const struct time
         return REDIS_ERR;
 
     c->connection_type = REDIS_CONN_UNIX;
-    if (c->unix.path != path)
-        c->unix.path = strdup(path);
+    if (c->c_unix.path != path)
+        c->c_unix.path = strdup(path);
 
     if (timeout) {
         if (c->timeout != timeout) {
