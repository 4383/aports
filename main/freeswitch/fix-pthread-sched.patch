Set sched priority via pthread_attr_* before thread is created.

This fixes segfault when trying to modify scheduling priority if thread
exits before pthread_setschedparam() is called.

diff --git a/libs/apr/threadproc/unix/thread.c b/libs/apr/threadproc/unix/thread.c
index 8859e79..a34e29f 100644
--- a/libs/apr/threadproc/unix/thread.c
+++ b/libs/apr/threadproc/unix/thread.c
@@ -174,19 +174,16 @@ APR_DECLARE(apr_status_t) apr_thread_create(apr_thread_t **new,
         return stat;
     }
 
-    if ((stat = pthread_create(&tt, temp, dummy_worker, (*new))) == 0) {
-
-#ifdef HAVE_PTHREAD_SETSCHEDPARAM
-		if (attr && attr->priority) {
-			int policy;
-			struct sched_param param = { 0 };
-
-			pthread_getschedparam(tt, &policy, &param);
-			param.sched_priority = attr->priority;
-			pthread_setschedparam(tt, policy, &param);
-		}
-#endif
+    if (attr && attr->priority) {
+        struct sched_param param;
+        if (pthread_attr_getschedparam(&attr->attr, &param) == 0) {
+            param.sched_priority = attr->priority;
+            pthread_attr_setschedparam(&attr->attr, &param);
+            pthread_attr_setinheritsched(&attr->attr, PTHREAD_EXPLICIT_SCHED);
+        }
+    }
 
+    if ((stat = pthread_create(&tt, temp, dummy_worker, (*new))) == 0) {
 		*(*new)->td = tt;
 
         return APR_SUCCESS;
