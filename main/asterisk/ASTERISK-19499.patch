From 6edcc6b28494ca4f23f42cf6c8d0fe76bbd1ce14 Mon Sep 17 00:00:00 2001
From: kharwell <kharwell@f38db490-d61c-443f-a65b-d21fe96a405b>
Date: Fri, 21 Feb 2014 15:27:53 +0000
Subject: [PATCH] channel.c: MOH is not working for transferee after attended
 transfer
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Updated the code to check to see if MOH is playing on the transferor and if
so then start it on the channel that replaces it during a masquerade.

Example scenario of the problem:
Alice calls Bob and then Bob begins the attended transfer process into a queue.
Upon going on hold Alice hears music and so does Bob once he is in the queue.
Bob then transfers Alice into the queue and then music for Alice stops even
though she should be hearing it since has now replaced Bob in the queue.

The problem that was occurring is that once the channel was masqueraded the app
(queues, confbridge, etc...) had no way of knowing that the channel had just
been swapped out thus it did not start music for the present channel.

Credit to Olle Johansson for pointing me in the right direction on this issue.

(closes issue ASTERISK-19499)
Reported by: Timo Ter√§s
Review: https://reviewboard.asterisk.org/r/3226/
........

Merged revisions 408642 from http://svn.asterisk.org/svn/asterisk/branches/1.8


git-svn-id: http://svn.digium.com/svn/asterisk/branches/11@408643 f38db490-d61c-443f-a65b-d21fe96a405b
---
 channels/chan_sip.c | 5 +++--
 main/channel.c      | 9 +++++++++
 2 files changed, 12 insertions(+), 2 deletions(-)

diff --git a/channels/chan_sip.c b/channels/chan_sip.c
index 32439d9..0c61fcd 100644
--- a/channels/chan_sip.c
+++ b/channels/chan_sip.c
@@ -24446,7 +24446,9 @@ static int attempt_transfer(struct sip_dual *transferer, struct sip_dual *target
 
 	if (peera && peerb && peerc && (peerb != peerc)) {
 		ast_quiet_chan(peera);		/* Stop generators */
-		ast_quiet_chan(peerb);
+		/* no need to quiet peerb since it should be hungup after the
+		   transfer and the masquerade needs to be able to see if MOH is
+		   playing on it */
 		ast_quiet_chan(peerc);
 		if (peerd)
 			ast_quiet_chan(peerd);
@@ -26103,7 +26105,6 @@ static int local_attended_transfer(struct sip_pvt *transferer, struct sip_dual *
 
 		ast_do_masquerade(target.chan1);
 
-		ast_indicate(target.chan1, AST_CONTROL_UNHOLD);
 		if (target.chan2) {
 			ast_indicate(target.chan2, AST_CONTROL_UNHOLD);
 		}
diff --git a/main/channel.c b/main/channel.c
index de0affd..a100aea 100644
--- a/main/channel.c
+++ b/main/channel.c
@@ -6821,6 +6821,7 @@ int ast_do_masquerade(struct ast_channel *original)
 	unsigned int orig_disablestatecache;
 	unsigned int clone_disablestatecache;
 	int visible_indication;
+	int moh_is_playing;
 	int clone_was_zombie = 0;/*!< TRUE if the clonechan was a zombie before the masquerade. */
 	struct ast_frame *current;
 	const struct ast_channel_tech *t;
@@ -6915,6 +6916,8 @@ int ast_do_masquerade(struct ast_channel *original)
 		xfer_colp = NULL;
 	}
 
+	moh_is_playing = ast_test_flag(ast_channel_flags(original), AST_FLAG_MOH);
+
 	/*
 	 * Stop any visible indication on the original channel so we can
 	 * transfer it to the clonechan taking the original's place.
@@ -7258,6 +7261,12 @@ int ast_do_masquerade(struct ast_channel *original)
 		ast_indicate(original, visible_indication);
 	}
 
+	/* if moh is playing on the original channel then it needs to be
+	   maintained on the channel that is replacing it. */
+	if (moh_is_playing) {
+		ast_moh_start(original, NULL, NULL);
+	}
+
 	ast_channel_lock(original);
 
 	/* Signal any blocker */
-- 
1.9.0

